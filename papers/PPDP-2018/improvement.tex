\section{The Search Improvement}
\label{improvement}

As we've seen in the previous section, the non-commutativity of conjunction in the presence of resursion
is one of the reasons for refutational incompleteness. Switching arguments of a certain conjunction
can sometimes improve the results; there is, however, no certain static order, beneficial in all cases.
Thus, we can make the following observations:

\begin{itemize}
\item the conjunction to change has to be properly identified;
\item the order of conjunct evaluation has to be a subject of a \emph{dynamic} choice.
\end{itemize}

Our improvement of the search is based on the idea of switching the order of conjuncts only when
the divergence of the first one is detected. More specifically: 

\begin{itemize}
\item during the search, we keep the track of all conjunctions being performed;
\item when we detect the divergence, we roll back to the nearest conjunction, for which 
we did not try all orders of constituents yet, switch its constituents, and rerun 
the search from that conjunction.
\end{itemize}

The important detail is the divergence test. Of course, due to the fundamental results in computability
theory, there is no hope to find a \emph{precise} computable test, which constitutes the necessary and 
sufficient condition of divergence. However, in our case a sufficient condition is sufficient. Indeed,  
a sufficient condition identifies a case, when the search, being continued, will lead to an incompleteness 
(since a divergence in our semantics always means incompleteness). Thus, it is no harm to try some other way. 

Another important question is the discipline of conjuncts reordering. Indeed, simply switching any two operands
of, for example, \mbox{$(g_1\wedge g_2)\wedge g_3$}, would not allow us to try \mbox{$(g_1\wedge g_3)\wedge g_2$}.
Thus, we have to flatten each ``cluster'' of nested conjunctions into a list of conjuncts\mbox{$\bigwedge g_i$}, 
where none of the goals $g_i$ is a conjunction. Then, it may seem at the first glance, that the number of orderings to try 
is exponential on the number of conjuncts; we are going to show, that, fortunately, this is not the case, and
a quadratic number of orders is suffucient.

In the rest of the section we address all these issues in details: first, we formally present the divergence
criterion and prove the necessity property; then, we describe an efficient reordering discipline. Finally, we present a
modified version of the semantics with incorporated divergence test and reordering. This semantics can be
considered as a modified version of the search, and we prove, that this modification is a proper improvement.

\subsection{The Divergence Test}

Our divergence test is based on the following notion:

\begin{definition}
\normalfont 
We say, that a vector of terms $\overline{a^{\phantom{x}}_i}$ is more general, than a vector of terms $\overline{b^{\phantom{x}}_i}$ (notation 
$\overline{a^{\phantom{x}}_i}\succeq\overline{b^{\phantom{x}}_i}$), if there is a substitution $\tau$, such that for $\forall i\;b_i = a_i \tau$.
\end{definition}

The idea of the divergence test is rather simple: it identifies a recursive call with more general arguments 
than (some) enclosing one. To state it formally and prove it using the semantics from section~\ref{language}, we need several definitions and lemmas.

\begin{definition}
\normalfont
A semantic variable $v$ is \emph{observable} w.r.t. the intrepretation $\iota$ and substitution $\sigma$, if there exists 
a syntactic variable $x$, such that \mbox{$v \in FV(\iota(x) \sigma)$}.
\end{definition}

\begin{definition}
\normalfont
A semantic statement 

$$
\otrans{\Gamma,\iota}{(\sigma,\,\delta)}{g}{S}
$$ 

\noindent is \emph{well-formed}, if \mbox{$dom(\sigma) \subseteq \delta$}, and any semantic variable, observable w.r.t. $\iota$ and $\sigma$, belongs to $\delta$.  
\end{definition}

Note, the root semantic statement \mbox{$\otrans{\Gamma,\bot}{(\epsilon,\,\emptyset)}{g}{S}$} is always well-formed.

\begin{lemma}
\label{one}
\normalfont
 For a well-formed semantic statement, every statement in its derivation tree is also well-formed.
\end{lemma}

The proof is by induction on the derivation tree. Note, we need to generalize the statement of the lemma, adding the well-formedness
condition w.r.t. $\iota$, $\sigma_r$, $\delta_r$ for any $(\sigma_r, \delta_r) \in S$.

The next lemma ensures, that any substitution in the RHS of a semantic statement is a correct refinement of that in the LHS:

\begin{lemma}
\label{two}
\normalfont
For a well-formed semantic statement 

$$
\otrans{\Gamma,\iota}{(\sigma,\,\delta)}{g}{S}
$$ 

\noindent and any result \mbox{$(\sigma_r,\,\delta_r) \in S$}, there exists a substitution $\Delta$, such that:
  \begin{enumerate}
    \item \mbox{$\sigma_r = \sigma\circ\Delta$};
    \item any semantic variable \mbox{$v\in dom(\Delta)\cup ran(\Delta)$} either is observable w.r.t. $\iota$ and $\sigma$,
 or does not belong to $\delta$ (where \mbox{$ran(\Delta)=\bigcup_{v\in dom(\Delta)}FV(\Delta(v))$}).
  \end{enumerate}   
\end{lemma}

The proof is by induction on the derivation tree; we as well need to generalize the statement of the lemma, adding the condition, that the 
set of all allocated semantic variables $\delta$ can only grow during the evaluation.

The final lemma formalizes the intuitive considerations, that the evaluation for a more general state cannot fail, if the evaluation 
for a more specific state doesn't fail:

\begin{lemma}
\label{three}
\normalfont
Let 

$$
\otrans{\Gamma,\iota}{(\sigma,\,\delta)}{g}{S}
$$ 

and 

$$\otrans{\Gamma,\iota^\prime}{(\sigma^\prime,\,\delta^\prime)}{g}{S^\prime}
$$

\noindent be two well-formed semantic statements, and let $\tau$ be a substitution, such that 
for any syntactic variable $x$ \mbox{$\iota^\prime(x) \sigma^\prime = \iota(x) \sigma \tau$}. Then the 
derivation tree for the first statement has greater or equal height, then the derivation 
tree for the second statement.
\end{lemma}

The proof is by induction on the derivation tree for the second statement. We need to generalize the statement of the lemma, adding the requirement, that 
for any substitution $s^\prime_r$ in the RHS of the second statement, there has to be a substitution $s_r$ in the RHS of the first statement,
such that there exists a substitution $\tau_r$, such that for any syntactic variable $x$ \mbox{$\iota^\prime(x) \sigma^\prime_r = \iota(x) \sigma_r \tau_r$}. 
In the cases of $\textsc{Fresh}$ and $\textsc{Invoke}$ rules, some semantic variables can become non-observable, and we need to define a substitution $\tau_r$ 
separately for these ``forgotten'' variables and those, which remain observable, using Lemma~\ref{two}.

Now we are ready to claim and prove the divergence criterion.

\setcounter{theorem}{0}
\begin{theorem}[Divergence criterion]
\label{criterion}
\normalfont
For any well-formed semantic statement 

$$
\otrans{\Gamma,\iota}{(\sigma,\,\delta)}{r^k\,t_1\dots t_k}{S}
$$ 

if its proper derivation subtree has a semantic statement 

$$
\otrans{\Gamma,\iota^\prime}{(\sigma^\prime,\,\delta^\prime)}{r^k\,t^\prime_1\dots t^\prime_k}{S^\prime}
$$

then \mbox{$\overline{t^\prime_i \iota^\prime \sigma^\prime} \not \succeq \overline{t^{\phantom{\prime}}_i \iota \sigma}$}. 
\end{theorem}
\begin{proof}
Assume, that \mbox{$\overline{t^\prime_i \iota^\prime \sigma^\prime}\succeq \overline{t^{\phantom{\prime}}_i \iota \sigma}$}. 

By Lemma~\ref{one}, the semantic statement

$$
\otrans{\Gamma,\iota^\prime}{(\sigma^\prime,\,\delta^\prime)}{r^k\,t^\prime_1\dots t^\prime_k}{S^\prime}
$$

\noindent is well-formed.

By Lemma~\ref{three}, the derivation tree for

$$
\otrans{\Gamma,\iota^\prime}{(\sigma^\prime,\,\delta^\prime)}{r^k\,t^\prime_1\dots t^\prime_k}{S^\prime}
$$

\noindent has greater or equal height, than that for

$$
\otrans{\Gamma,\iota}{(\sigma,\,\delta)}{r^k\,t_1\dots t_k}{S}
$$ 

\noindent which contradicts the theorem condition.

\end{proof}

The theorem justifies that, indeed, our test constitutes a sufficient condition for a divergence: if the execution
reaches a relation call with more general arguments, than those of some enclosing one, then it has no derivation
in our semantics, and, thus, it is not terminating.

\subsection{Conjuncts Reordering}

In this section we consider the discipline of conjuncts reordering. Recall, we flatten all nested conjunctions in 
clusters $\wedge g_i$, where none of $g_i$ is a conjunction. To evaluate a cluster, we have to evaluate
its conjuncts one after another, threading the results, starting from the initial substitution. Each time we
evaluate a conjunct, we can have three possible outcomes:

\begin{itemize}
\item The evaluation converges with some result. In this case we can proceed with the next conjunct.
\item The evaluation diverges undetected. In this case nothing can be done.
\item A divergence is detected by the test. This is the case when the reordering takes place.
\end{itemize}

In a general case, for each cluster we can have some converging prefix $\omega$ we've managed to evaluate so far (initially empty),
and the rest of the conjuncts $g_i$. Since $\omega$ converges, we have some set of substitutions $S_\omega$, which corresponds to the
result of $\omega$ evaluation.

Suppose none of $g_i$ converges on $S_\omega$ (i.e. there is atleast one substitution in $S_\omega$, on which
each $g_i$ diverges). We claim, that reordering conjuncts inside $\omega$ would not help. Indeed, with any other order
of conjuncts $\omega$ either diverges, or converges with the same result (up to the renaming of semantic variables). Thus,
making any permutations inside $\omega$ is superfluous.

Next, suppose we have two different goals $g_1$ and $g_2$, which both converge on $S_\omega$ (i.e. both converge on each
substitution in $S_\omega$). Do we need to try both cases ($g_1$ and $g_2$) to extend the converging prefix?
It is rather easy to see, that if, say, $g_2$ is converges on $S_\omega$, it will as well converge on the result of evaluation
of $g_1$ on $S_\omega$. In other words, to extend a converging prefix we can choose arbitrary conjunct, which converges immediately
after this prefix, and this choice will never has to be undone.

Now we can specify the reordering discipline. We attach two natural numbers $i$ and $p$ to each cluster; initially $i=0$, $p=1$.
Informally speaking, $i$ corresponds to the length of the converging prefix, while $p\ge i$~--- to the number of the conjunct ouside the prefix
to try next. Given current cluster $\wedge g_1\dots g_k$, current set $S$, and some $i$ and $p$, we proceed as follows:

\begin{enumerate}
\item\label{reorder:top} If $i>k$, then the whole cluster converges, and $S$~--- the result of its evaluation.
\item Otherwise, we try to evaluate $g_i$ on $S$. If the evaluation succeeds with the result $S^\prime$, then we increment $i$, assume $p=i+1$ and
$S=S^\prime$, and continue from step~\ref{reorder:top}.
\item If a divergence is detected, and $p\le k$, then we switch $g_i$ with $g_p$, increment $p$, and continue from step~\ref{reorder:top}.
\item Otherwise, we give up and rollback to the enclosing cluster (if any).
\end{enumerate}

Thus, we apply a greedy approach: each time we have a converging prefix of conjuncts (possibly empty), and some tail. We try to put each conjunct
from the tail immediately after the prefix. If we find a converging conjunct, we attach it to the prefix and continue; if no, then the list of 
conjuncts diverges. Thus, we can find a converging order (if any) in a quadratic time.

\subsection{Improved Search Sematics}

We express the improved search in terms of a big-step operational semantics. This semantics is an extension of the initial one, presented in Section~\ref{language}, which
incorporates all the components, considered in the previous subsections: the divergence test, conjunct clustering and reordering.

First, we extend the environment, adding three additional components:

See Fig.~\ref{improved-semantics-invoke}, Fig.~\ref{improved-semantics-normal}, Fig.~\ref{improved-semantics-divergence-prop} and Fig.~\ref{improved-semantics-reordering}.


\setarrow{\xRightarrow}
\setsubarrow{_e}
\begin{figure*}
\begin{minipage}[t]{\textwidth}
\small
\[
\cotrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{t_1\equiv t_2}{\emptyset}{mgu\,(t_1\iota\sigma,\,t_2\iota\sigma) = \bot}\ruleno{UnifyFail$^+$}
\]
\[
\cotrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{t_1\equiv t_2}{(\sigma\circ\Delta,\,\delta)}{mgu\,(t_1\iota\sigma,\,t_2\iota\sigma) = \Delta\ne\bot}\ruleno{UnifySuccess$^+$}
\]
\[
\trule{\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_1}{S_1};\quad
       \otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_2}{S_2}
      }
      {\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_1\vee g_2}{S_1\cup S_2}}\ruleno{Disj$^+$}
\]
\[
\crule{\otrans{\Gamma,\,\iota[x\gets\alpha],\,h}{(\sigma,\,\delta\cup\{\alpha\})}{g}{\mathscr R}}
      {\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{\lstinline|fresh($x$) $\;g$|}{\mathscr R}}
      {\alpha\in\meta{W}\setminus\delta}\ruleno{Fresh$^+$}
\]
\end{minipage}      
\caption{Improved search: inherited rules}
\label{improved-semantics-normal}
\end{figure*}

\begin{figure*}
\begin{minipage}[t]{\textwidth}
\small
\[
   \cotrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{r^k t_1 \dots t_k}{\bot}{v_i = t_i \iota \sigma, \; (v_1, \dots, v_k) \succeq h\,r^k}
   \ruleno{InvokeDiv$^+$}
\]

\[
\crule{\otrans{\Gamma,\,\epsilon[x_i\gets v_i],\,h[r^k\gets(v_1, \dots, v_k)]}{(\epsilon,\,\delta)}{g}{\{(\sigma_i,\,\delta_i)\}}}
      {\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{r^k t_1 \dots t_k}{\{(\sigma\circ\sigma_i, \delta_i)\}}}
      {v_i=t_i\iota\sigma,\;\Gamma\,r^k=\lambda x_1 \dots x_k. g,\; (v_1, \dots, v_k) \nsucceq h\,r^k}
      \ruleno{Invoke$^+$}
\]
\end{minipage}      
\caption{Improved search: invocation and divergence detection}
\label{improved-semantics-invoke}
\end{figure*}

\begin{figure*}
\begin{minipage}[t]{\textwidth}
\small
\[
\trule{\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_1}{\bot}}
      {\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_1\vee g_2}{\bot}}\ruleno{DivDisjLeft$^+$}
\]
\[
\trule{\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_2}{\bot}}
      {\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_1\vee g_2}{\bot}}\ruleno{DivDisjRight$^+$}
\]
\[
\crule{\otrans{\Gamma,\,\epsilon[x_i\gets v_i],\,h[r^k\gets(v_1, \dots, v_k)]}{(\epsilon,\,\delta)}{g}{\bot}}
      {\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{r^k t_1 \dots t_k}{\bot}}
      {v_i=t_i\iota\sigma,\;\Gamma\,r^k=\lambda x_1 \dots x_k. g,\; (v_1, \dots, v_k) \nsucceq h\,r^k}
      \ruleno{DivInvoke$^+$}
\]      
\end{minipage}      
\caption{Improved search: divergence propagation}
\label{improved-semantics-divergence-prop}
\end{figure*}

\begin{figure*}
\begin{minipage}[t]{\textwidth}
\small
\[
\trule{\setsubarrow{_r}\otrans{\Gamma,\,\iota,\,h,\,1}{(\sigma,\,\delta)}{\bigwedge\limits_{i=1}^n g_i}{\mathscr R}}
      {\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{\bigwedge\limits_{i=1}^n g_i}{\mathscr R}}
      \ruleno{ClusterStart$^+$}
\]
\vskip3mm
\[
\crule{\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_p}{\{(\sigma_j,\,\delta_j)\}};\quad
       \forall j\;:\;\otrans{\Gamma,\,\iota,\,h}{(\sigma_j,\,\delta_j)}{\bigwedge\limits_{i\ne p}g_i}{S_j}
      }
      {\setsubarrow{_r}\otrans{\Gamma,\,\iota,\,h,\,p}{(\sigma,\,\delta)}{\bigwedge\limits_{i=1}^n g_i}{\bigcup S_j}}
      {1 \le p \le n}
\ruleno{ClusterStep$^+$}
\]
\vskip3mm
\[
\crule{\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_p}{\{(\sigma_j,\,\delta_j)\}};\quad
       \exists j\;:\;\otrans{\Gamma,\,\iota,\,h}{(\sigma_j,\,\delta_j)}{\bigwedge\limits_{i\ne p}g_i}{\bot}
      }
      {\setsubarrow{_r}\otrans{\Gamma,\,\iota,\,h,\,p}{(\sigma,\,\delta)}{\bigwedge\limits_{i=1}^n g_i}{\bot}}
      {1 \le p \le n}
\ruleno{ClusterDiv$^+$}
\]
\vskip3mm
\[
\crule{\otrans{\Gamma,\,\iota,\,h}{(\sigma,\,\delta)}{g_p}{\bot};\quad
       {\setsubarrow{_r}\otrans{\Gamma,\,\iota,\,h,\,p+1}{(\sigma,\,\delta)}{\bigwedge\limits_{i=1}^n g_i}{\mathscr R}}
      }
      {\setsubarrow{_r}\otrans{\Gamma,\,\iota,\,h,\,p}{(\sigma,\,\delta)}{\bigwedge\limits_{i=1}^n g_i}{\mathscr R}}
      {1 \le p \le n}
\ruleno{ClusterNext$^+$}
\]
\vskip3mm
\[
\cotrans{\Gamma,\,\iota,\,h,\,p}{(\sigma,\,\delta)}{\bigwedge\limits_{i=1}^n g_i}{\bot}{p>n}
\ruleno{ClusterStop$^+$}
\]
\end{minipage}      
\caption{Improved search: conjuncts reordering}
\label{improved-semantics-reordering}
\end{figure*}



\begin{comment}

\begin{theorem}
      Для любых $\Gamma$, $\iota$, $\sigma$, $\delta$, $g$, и $S$,
      
      \[ \searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S} \Rightarrow \extSearchRule{\Gamma}{\iota}{\epsilon}{0}{\sigma}{\delta}{g}{S}, \]
      где $\epsilon$ --- пустое множество записей о предыдущих вызовах (всюду неопределенная функция).
\end{theorem}
\begin{proof}$ $\par\nobreak\ignorespaces
      Для индукционного доказательства утверждение нужно сформулировать в более общем виде: для любого $h$, если для любого $r^k$, такого что $h(r^k) = (v_1, \dots, v_n)$ для некоторых значений $v_i$, существует дерево вывода утверждения $\searchRule{\Gamma}{\iota'}{\sigma'}{\delta'}{\lstinline|$r^k$ $t_1$ $\dots$ $t_k$|}{S}$ для некоторых $t_i$, таких что $t_i \iota' \sigma' = v_i$, и у этого дерева есть поддерево, в котором выводится утверждение $\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S}$, тогда $\searchRule{\Gamma}{\iota}{\sigma}{\delta}{g}{S} \Rightarrow \extSearchRule{\Gamma}{\iota}{h}{0}{\sigma}{\delta}{g}{S}$.
      
      Это утверждение доказывается идукцией по дереву вывода утверждения в семантике стандартного поиска, строится аналогичное дерево в семантике расширенного поиска.
      
      Во всех случаях, кроме вызова отношения можно использовать при построении те же самые правила. В случае вызова отношения необходимо так же знать, что текущие значения аргументов не являются более общими, чем значения аргументов при предыдущем вызове (хранящиеся в $h$), но это следует из корректности критерия (чтобы применить его формально, используется условие на $h$ из формулировки утверждения).
      
\end{proof}

\end{comment}




% (Lemma~\ref{three} from Appendix~\ref{appendix}
%can be used to justify this claim). Thus, we do not to try two cases.


\begin{comment}
First, we need a way to detect 
a situation, when we give up on current conjunction and proceed to the next enclosing one (if any).
We represent a cluster of nested conjunctions as a state \mbox{$([p_i], n, [s_i])$}, where $[p_i]$, $[s_i]$ are lists of
non-conjunction goals, $n$~--- some natural number. We call $[p_i]$ a prefix, $[s_i]$~--- a suffix, and $n$~--- a position. 
Initially, the prefix is empty, $n=0$, and the suffix consists of the list of all conjuncts.

Let \mbox{$[p_i], n, [s_1,\dots]$} be a state; we try to evaluate $s_1$. There are three possible outcomes:

\begin{enumerate}
\item The evaluation converges; then we change the state into \mbox{$[p_i,s_1], 0, [s_2\dots]$} and continue.
\item The evaluation ends with a signal, that a divergence was detected inside the evaluation of $s_1$. We
change the state into \mbox{$[p_i], n+1, [s_{n+1},\dots,s_n=s_1,\dots]$} (in other words, we switch $s_1$ with 
$s_{n+1}$).
\item The evaluation diverges without detectiong. Nothing can be done in this case.
\end{enumerate}



We also need to pay a special attention to make it possible to enumerate all orders of all conjuncts in
compound conjunctions, not only immediate ones; thus, in \mbox{$(g_1\wedge g_2)\wedge g_3$} we should
be able to try not only \mbox{$(g_1\wedge g_2)\wedge g_3$} and \mbox{$g_3 \wedge(g_1\wedge g_2)$}, but, 
for example, \mbox{$(g_2\wedge g_1)\wedge g_3$}, etc. It can be easily achieved by flattening all nested
conjunctions to a \emph{cluster} $\bigwedge g_i$, where none of $g_i$ is a conjunction. 

In may seem at a first glance, that in the worst case an exponential number of conjunct orders have to
be tried. This is, actually, not true, because we do not need to try different orders in the
converging prefix of conjuncts. We present the following discipline of reordering:

\begin{itemize}
\item We associate a natural number $n$ with each cluster of conjuncts; initially this
number is $0$. Informally, the non-zero value $k$ says, that we reordered the cluster by
putting $k$-th conjuncts in the first place.
\item    
\end{itemize}



Moreover, all orders tried so far, have to be memorized. When we tried out every one, we need to 
proceed to the next enclosing conjunction (if any). Note, in this approach we modify the conjunctions 
according to their dynamic evaluation order, not static scoping. 


Now it is sufficient to present a query, which is not refutationally complete w.r.t. to the semantics, 
but becomes refutationally complete w.r.t. to the improvement. For such query we can take 
\mbox{\lstinline|fresh ($p\;q$) (append$^o\;p\;q\;$ Nil)|}~--- indeed, from Section~\ref{incompleteness} we
already know, that it diverges. We also remember that the reason of the divergence is the infinite
sequence of recursive calls with renamed arguments~--- but this means, that the divergence test is satisfied.
Finally, switching the recursive call to \lstinline|append$^o$| with the preceding conjunct makes the query converge~--- this is exactly, what the improvement does.



\end{comment}
