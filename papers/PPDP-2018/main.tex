\documentclass[sigconf]{acmart}

\usepackage{booktabs} % For formal tables
\usepackage{amssymb}
\usepackage{mathtools}
\usepackage{multirow}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{comment}
\usepackage{wrapfig}
\usepackage[caption=false]{subfig}
\usepackage{placeins}
\usepackage{tabularx}
\usepackage{ragged2e}

\def\transarrow{\xrightarrow}
\newcommand{\setarrow}[1]{\def\transarrow{#1}}

\newcommand{\trule}[2]{\frac{#1}{#2}}
\newcommand{\crule}[3]{\frac{#1}{#2},\;{#3}}
\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\trans}[3]{{#1}\transarrow{#2}{#3}}
\newcommand{\ctrans}[4]{{#1}\transarrow{#2}{#3},\;{#4}}
\newcommand{\llang}[1]{\mbox{\lstinline[mathescape]|#1|}}
\newcommand{\pair}[2]{\inbr{{#1}\mid{#2}}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\highlight}[1]{\color{red}{#1}}
\newcommand{\ruleno}[1]{\eqno[\scriptsize\textsc{#1}]}
\newcommand{\rulename}[1]{\textsc{#1}}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\lfp}[1]{fix_{#1}}
\newcommand{\gfp}[1]{Fix_{#1}}
\newcommand{\vsep}{\vspace{-2mm}}
\newcommand{\supp}[1]{\scriptsize{#1}}
\renewcommand{\G}{\mathfrak G}
\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\miniKanren}{miniKanren\xspace}
\newcommand{\ocanren}{OCanren\xspace}
\newcommand{\free}[1]{\boxed{#1}}
\newcommand{\binds}{\;\mapsto\;}
\newcommand{\dbi}[1]{\mbox{\bf{#1}}}
\newcommand{\sv}[1]{\mbox{\textbf{#1}}}
\newcommand{\bnd}[2]{{#1}\mkern-9mu\binds\mkern-9mu{#2}}

\newcommand{\meta}[1]{{\mathcal{#1}}}
\renewcommand{\emptyset}{\varnothing}

\lstdefinelanguage{ocanren}{
keywords={fresh, let, in, match, with, when, class, type,
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, success, failure,
true, false},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\\/}{{$\vee$}}2 {/\\}{{$\wedge$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocanren
}

\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}
%\addtolength{\parskip}{-2pt}
\pagestyle{plain}


% Copyright
%\setcopyright{none}
%\setcopyright{acmcopyright}
%\setcopyright{acmlicensed}
\setcopyright{rightsretained}
%\setcopyright{usgov}
%\setcopyright{usgovmixed}
%\setcopyright{cagov}
%\setcopyright{cagovmixed}


% DOI
%\acmDOI{10.475/123_4}

% ISBN
%\acmISBN{123-4567-24-567/08/06}

%Conference
%\acmConference[WOODSTOCK'97]{ACM Woodstock conference}{July 1997}{El
%  Paso, Texas USA}
%\acmYear{1997}
%\copyrightyear{2016}


%\acmArticle{4}
%\acmPrice{15.00}

% These commands are optional
%\acmBooktitle{Transactions of the ACM Woodstock conference}
%\editor{Jennifer B. Sartor}
%\editor{Theo D'Hondt}
%\editor{Wolfgang De Meuter}

\begin{comment}
First, the evaluation needs to give more information. How many cases did you try, and where can we download those specifications? Substantiate your claims of comparable or faster performance using quantitative data. What are some cases where the improvement almost works but unfortunately fails? Why restrict your claims to "the queries which return a finite number of answers"?

Second, the improvement should be described using the formal framework already set up in Section 2. That would clarify the description towards the end of Section 4. As it stands, it is not completely clear what "a greedy approach" is -- given the knowledge that "the list of conjuncts diverges", the question remains as to how to reorder the conjuncts and sometimes go "even more back" (as mentioned in Section 5.1). In other words, the paper should show and explain what Figure 2 becomes with the improvement. Only then is the claim of "quadratic time" meaningful.

Chapter 4 continues the discussion on the problem of non-commutativity of conjunctions and proposes the optimization technique progressively. But the completed version of the optimization algorithm is not clearly stated in an individual paragraph. At least a short summary on the core algorithm of this paper should be necessary. A more detailed and formal one would even be better.

The paper talks about the effectiveness of the optimization, however, a reader may be interested in the limitation of this technique. Since the divergence test is sufficient but not necessary, the paper may discuss about when this optimization works and when it does not.

My main problem with this paper is its presentation. Much of the paper
is devoted to a formal system of syntax and semantics. I find the
description there long winded, and does not highlight the non-standard
parts if there is any. To make the matter worse, the formal system is
not used at all, as no result is presented in the main text. Even if
space is an issue, at least the main theorem shall be presented.

I also find the section of implementation and evaluation slightly
disappointing. No detail of the deep embedding is shown, and the a few
examples are by no means an “evaluation”. I am also confused by the
very informal nature of the presentation in this section. For example,
how is the problem with “perm” solved? Since the problem is that the
evaluation goes both directions, how can reordering help? I also do
not understand the example of Binary arithmetic as very little code is
shown.
\end{comment}

\sloppy

\begin{document}

\title{Improving Refutational Completeness\\
of Relational Search via Divergence Test}

\titlenote{Produces the permission block, and
  copyright information}

\author{Dmitri Rozplokhas}
\affiliation{%
  \institution{St. Petersburg Academic University}
  \streetaddress{Khlopina st., 8-3-А}
  \city{St. Petersburg}
  \state{Russia}
  \postcode{194021}
}
\email{rozplokhas@gmail.com}

\author{Dmitri Boulytchev}
\affiliation{%
  \institution{St. Petersburg State University}
  \streetaddress{Universitetskaya emb., 7-9}
  \city{St. Petersburg}
  \state{Russia}
  \postcode{199034}
}
\email{dboulytchev@math.spbu.ru}

% The default list of authors is too long for headers.
%\renewcommand{\shortauthors}{B. Trovato et al.}

\begin{abstract}
We describe a search optimization technique for implementation of relational programming language
miniKanren which makes more queries to converge. Our technique is based on a certain 
divergence criterion, which we use to trigger a dynamic reordering of subgoals. We present a formal semantics of
miniKanren-like language, and prove, that our optimization does not compromise already
converging programs, thus being a proper improvement. We also present the prototype
implementation of improved search and demonstrate its application for a number of
useful specifications.
\end{abstract}

%
% The code below should be generated by the tool at
% http://dl.acm.org/ccs.cfm
% Please copy and paste the code instead of the example below.
%
\begin{CCSXML}
<ccs2012>
<concept>
<concept_id>10003752.10003790.10003795</concept_id>
<concept_desc>Theory of computation~Constraint and logic programming</concept_desc>
<concept_significance>500</concept_significance>
</concept>
<concept>
<concept_id>10003752.10010124.10010131.10010134</concept_id>
<concept_desc>Theory of computation~Operational semantics</concept_desc>
<concept_significance>100</concept_significance>
</concept>
<concept>
<concept_id>10011007.10011006.10011008.10011009.10011015</concept_id>
<concept_desc>Software and its engineering~Constraint and logic languages</concept_desc>
<concept_significance>500</concept_significance>
</concept>
</ccs2012>
\end{CCSXML}

\ccsdesc[500]{Theory of computation~Constraint and logic programming}
\ccsdesc[100]{Theory of computation~Operational semantics}
\ccsdesc[500]{Software and its engineering~Constraint and logic languages}

\keywords{relational programming, refutational completeness, divergence test}

\maketitle

\input{introduction.tex}
\input{language.tex}
\input{incompl.tex}
\input{improvement.tex}
\input{evaluation.tex}
\input{conclusion.tex}

\bibliographystyle{ACM-Reference-Format}
\bibliography{main}

\end{document}
