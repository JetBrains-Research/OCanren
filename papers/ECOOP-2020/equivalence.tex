\section{Equivalence of Semantics}
\label{equivalence}

Now when we defined two different kinds of semantics for \textsc{miniKanren} we can relate them and show that the results given by these two semantics are the same for any specification.
This will actually say something important about the search in the language: since operational semantics describes precisely the behavior of the search and denotational semantics
ignores the search and describes what we \emph{should} get from a mathematical point of view, by proving their equivalence we establish the \emph{completeness} of the search, which
means that the search will get all answers satisfying the described specification and only those.

But first, we need to relate the answers produced by these two semantics as they have different forms: a trace of substitutions (along with the numbers of allocated variables)
for the operational one and a set of representing functions for the denotational one. We can notice that the notion of representing function is close to substitution, with only two differences:

\begin{itemize}
\item representing function is total;
\item terms in the domain of representing function are ground.
\end{itemize}

Therefore we can easily extend (perhaps ambiguously) any substitution to a representing function by composing it with an arbitrary representing function which preserves
all variable dependencies in the substitution. So we can define a set of representing functions corresponding to a substitution as follows:

\[
[\sigma] = \{\overline{\mathfrak f} \circ \sigma \mid \mathfrak{f}:\mathcal{A}\mapsto\mathcal{D}\}
\]

\begin{comment}
In \textsc{Coq} this notion boils down to the following definition:

\begin{lstlisting}[language=Coq]
   Definition in_denotational_sem_subst
     (s : subst) (f : repr_fun) : Prop :=
       exists (f' : repr_fun),
         repr_fun_eq (subst_repr_fun_compose s f') f.
\end{lstlisting}

where ``\lstinline[language=Coq]|repr_fun_eq|'' stands for representing functions extensional equality, ``\lstinline[language=Coq]|subst_repr_fun_compose|''~---
for a composition of a substitution and a representing function.
\end{comment}

And the \emph{denotational analog} of operational semantics (a set of representing functions corresponding to the answers in the trace) for a given extended state $s$ is
then defined as the union of sets for all substitution in the trace:

\[
\sembr{s}_{op} = \cup_{(\sigma, n) \in \tr{s}} [\sigma]
\]

\begin{comment}
In \textsc{Coq} we again use a proposition instead:

\begin{lstlisting}[language=Coq]
   Definition in_denotational_analog
      (t : trace) (f : repr_fun) : Prop :=
      exists s n, in_stream (Answer s n) t /\
             in_denotational_sem_subst s f.
   Notation "{| t , f |}" := (in_denotational_analog t f).
\end{lstlisting}
\end{comment}

This allows us to state theorems relating two semantics.

\begin{theorem}[Operational semantics soundness]
\label{OpSemSoundnessThm}
If indices of all free variables in a goal $g$ are limited by some number $n$, then

\[
\sembr{\inbr{g, \epsilon, n}}_{op} \subset \sembr{g}.
\]
\end{theorem}

It can be proven by nested induction, but first, we need to generalize the statement so that the inductive hypothesis would be strong enough for the inductive step.
To do so, we define denotational semantics not only for goals but for arbitrarily extended states. Note that this definition does not need to have any intuitive
interpretation, it is introduced only for proof to go smoothly. The definition of the denotational semantics for extended states is shown on Figure~\ref{denotational_semantics_of_states}.
The generalized version of the theorem uses it:

\begin{figure}[t]
  \[
  \begin{array}{ccl}
    \sembr{\Diamond}&=&\emptyset\\
    \sembr{\inbr{g, \sigma, n}}&=&\sembr{g}\cap[\sigma]\\
    \sembr{s_1 \oplus s_2}&=&\sembr{s_1}\cup\sembr{s_2}\\
    \sembr{s \otimes g}&=&\sembr{s}\cap\sembr{g}\\
  \end{array}
  \]
  \caption{Denotational semantics of states}
  \label{denotational_semantics_of_states}
\end{figure}

\begin{lemma}[Generalized soundness]
\label{GenSoundnessLemma}
For any well-formed extended state $s$

\[
\sembr{s}_{op} \subset \sembr{s}.
\]
\end{lemma}

It can be proven by the induction on the number of steps in which a given answer (more accurately, the substitution that contains it) occurs in the trace.
We break the proof in two parts and separately prove that for every transition in our system the semantics of both the label (if there is one)
and the next state are subsets of the denotational semantics for the initial state.

\begin{lemma}[Soundness of the answer]
\label{AnswerSoundnessLemma}
For any well-formed extended state $s$ and any transition $s \xrightarrow{(\sigma, n)} s'$,

\[
[\sigma] \subset \sembr{s}.
\]
\end{lemma}
\begin{proof}
  The proof is by induction on the transition relation. The only non-trivial case here is the rule \textsc{UnifySuccess} (the only rule where the answer is created, not passed through).
  Here we need to show that any representing function that is an extension of $mgu\,(t_1 \sigma, t_2 \sigma) \circ \sigma$ unifies terms $t_1$ and $t_2$ and is an extension of $\sigma$.
  These rather trivial (as long as we have proven the properties of mgu) statements require some technical work with the properties of representing functions.
\end{proof}

\begin{lemma}[Soundness of the next state]
\label{NextStateSoundnessLemma}
For any well-formed extended state $s$ and any transition $s \xrightarrow{(\sigma, n)} s'$,

\[
\sembr{s'} \subset \sembr{s}.
\]
\end{lemma}
\begin{proof}
The proof is by straightforward induction on the transition relation. In cases where the initial state is a partially-evaluated conjunction we need the previous lemma.
\end{proof}

It would be tempting to formulate the completeness of operational semantics as soundness with the inverted inclusion, but it does not hold in such generality.
The reason for this is that the denotational semantics encodes only the dependencies between free variables of a goal, which is reflected by the completeness condition,
while the operational semantics may also contain dependencies between semantic variables allocated in ``\lstinline|fresh|''. Therefore we formulate completeness
with representing functions restricted on the semantic variables allocated in the beginning (which includes all free variables of a goal). This does not
compromise our promise to prove the completeness of the search as \textsc{miniKanren} provides the result as substitutions only for queried variables,
which are allocated in the beginning.

\begin{theorem}[Operational semantics completeness]
If indices of all free variables in a goal $g$ are limited by some number $n$, then

\[
\{\mathfrak{f}|_{\{\alpha_1,\dots,\alpha_n\}} \mid \mathfrak{f} \in \sembr{g}\} \subset \{\mathfrak{f}|_{\{\alpha_1,\dots,\alpha_n\}} \mid \mathfrak{f} \in \sembr{\inbr{g, \epsilon, n}}_{op}\}.
\]
\end{theorem}


Similarly to the soundness, this can be proven by nested induction, but the generalization is required. This time it is enough to generalize it from goals
to states of the shape $\inbr{g, \sigma, n}$. We also need to introduce one more auxiliary semantics~--- \emph{a bounded denotational semantics}:

\[
\sembr{\bullet}^l : \mathcal{G} \to 2^{\mathcal{A}\to\mathcal{D}}
\]

Instead of always unfolding the definition of a relation for invocation goal, it does so only the given number of times. So for a given set of relational
definitions $\{R_i^{k_i} = \lambda\;x_1^i\dots x_{k_i}^i\,.\, g_i\}$ the definition of bounded denotational semantics is exactly the same as for the conventional denotational semantics,
except that for the invocation case we have

\[
\sembr{R_i^{k_i}\,(t_1,\dots,t_{k_i})}^{l+1} = \sembr{g_i[t_1/x_1^i, \dots, t_{k_i}/x_{k_i}^i]}^{l}
\]

It is convenient to define bounded semantics for level zero as the empty set:

\[
\sembr{g}^{0} = \emptyset
\]

The bounded denotational semantics is an approximation of the conventional denotational semantics; it is clear that any answer in the conventional denotational semantics will also be in
the bounded denotational semantics for some level:

\begin{lemma}
$\sembr{g} \subset \cup_l \sembr{g}^l$
\end{lemma}

Formally it can be proven using the definition of the least fixed point from the Tarski-Knaster theorem: the set on the right-hand side is a closed set.

Now the generalized version of the completeness theorem is as follows:

\begin{lemma}[Generalized completeness]
\label{GenCompletenessLemma}
For any set of relational definitions, for any level $l$, for any well-formed state $\inbr{g, \sigma, n}$,

\[
\{\mathfrak{f}|_{\{\alpha_1,\dots,\alpha_n\}} \mid \mathfrak{f} \in \sembr{g}^l \cap [\sigma]\} \subset \{\mathfrak{f}|_{\{\alpha_1,\dots,\alpha_n\}} \mid \mathfrak{f} \in \sembr{\inbr{g, \sigma, n}}_{op}\}.
\]
\end{lemma}
\begin{proof}
The proof is by the induction on the level $l$. The induction step is proven by structural induction on the goal $g$.
\begin{itemize}
\item If the goal is $t_1\equiv t_2$ we need to show that any representing function that unifies terms $t_1$ and $t_2$ and is an extension of $\sigma$ also is an extentsion of $mgu\,(t_1 \sigma, t_2 \sigma) \circ \sigma$. This again requires some observations about representing functions, most importantly the fact that for any representing function $f$, unifying two terms, there exists a unifying substitution for these terms, for which $f$ is an extension.
\item If the goal is $g_1\vee g_2$ we use lemma~\ref{InterleavingInLemma} that guarantees that any answer in the trace for $s_1$ or in the trace for $s_2$ will also occur in trace for $s_1 \oplus s_2$.
\item If the goal is $g_1\wedge g_2$ we use the similar observation about partially-evaluated conjunctions (for any answer $(\sigma, n)$ in the trace starting from $s$, any answer in the trace starting from $\inbr{g, \sigma, n}$ will also occur in the trace for $s \otimes g$). We also need the completeness condition and the fact that the number of allocated variables only increases during the execution.
\item The case when the goal is $\mbox{\lstinline|fresh|}\,x\,.\,g'$ is actually very non-trivial because given representing function from the denotational semantics may come from a subsitution of fresh-bound variable with \emph{any} non-free variable, not necessarily the next one allocated. To overcome this difficulty we need the restriction on allocated variables in theorem statement; we also need the ``monstrous'' lemma~\ref{ChangeFreeVarLemma} about switching fresh variable and have to carefully change the value of a given function in a few points to be able to use the induction hypothesis appropriately.
\item If the goal is $R\,(t_1,\dots,t_k)$ we simply use the induction hypothesis about the previous level.
\end{itemize}
\end{proof}

The proofs of both theorems are certified in \textsc{Coq}; for completeness, we can not just use the induction on proposition \lstinline|in_denotational_sem_goal|, as it would be natural to expect,
because the inductive principle it provides is not flexible enough. So we need to define the bounded denotational semantics in our formalization and perform
induction on the level explicitly.

  The final proofs are relatively small, but the large amount of work is hidden in the proofs of auxiliary facts. The total size of the proofs of soundness is 70 LOC and for the proofs of
  completeness it is roughly 450 LOC (this includes the proofs of observations about representing functions, operational and denotational semantics that are necessary for the final proof
  and not important on their own, but excluding properties of unifiers, streams and so on).

\begin{comment}
\begin{lstlisting}[language=Coq,morekeywords={where,at,level}]
  Reserved Notation "[| n | g , f |]" (at level 0).
  Inductive in_denotational_sem_lev_goal :
    nat -> goal -> repr_fun -> Prop :=
    ...
  | dslgInvoke : forall l r t f,
      [| l  | proj1_sig (Prog r) t , f |] ->
      [| S l | Invoke r t , f |]
  where "[| n | g , f |]" :=
    (in_denotational_sem_lev_goal n g f).
\end{lstlisting}

Recall that the environment ``\lstinline[language=Coq]|Prog|'' maps every relational symbol to the definition of relation,
which is a pair of a function from terms to goals and a proof that it is closed and consistent.
So ``\lstinline[language=Coq]|(proj1_sig (Prog r) t)|'' here simply takes the body of the corresponding relation.

The lemma relating bounded and unbounded denotational semantics in \textsc{Coq} looks as follows:

\begin{lstlisting}[language=Coq] 
  Lemma in_denotational_sem_some_lev:
    forall (g : goal) (f : repr_fun),
      [| g , f |] -> exists l, [| l | g , f |].
\end{lstlisting}

The statements of the theorems are as follows:

\begin{lstlisting}[language=Coq]]
  Theorem search_correctness:
    forall (g : goal) (k : nat) (f : repr_fun) (t : trace),
      closed_goal_in_context (first_nats k) g) ->
      op_sem (State (Leaf g empty_subst k)) t) ->
      {| t , f |} ->
      [| g , f |].
  Theorem search_completeness:
    forall (g : goal) (k : nat) (f : repr_fun) (t : trace),
      consistent_goal g ->
      closed_goal_in_context (first_nats k) g ->
      op_sem (State (Leaf g empty_subst k)) t ->
      [| g , f |] ->
      exists (f' : repr_fun),
        {| t , f' |} /\
        forall (x : var), In x (first_nats k) -> f x = f' x.
\end{lstlisting}
\end{comment}
