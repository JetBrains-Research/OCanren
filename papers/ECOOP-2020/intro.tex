\section{Introduction}

In the context of this paper, we understand ``relational programming'' as a puristic form of logic programming with all extra-logical
features banned. Specifically, we use \textsc{miniKanren} as an exemplary language; \textsc{miniKanren} can be seen as
a logical language with explicit connectives, existentials and unification, and is mutually convertible to the pure logical subset of
\textsc{Prolog}\footnote{A detailed \textsc{Prolog}-to-\textsc{miniKanren} comparison can be found here: \url{http://minikanren.org/minikanren-and-prolog.html}}.
Unlike \textsc{Prolog}, which relies on SLD-resolution, most \textsc{miniKanren} implementations use monadic \emph{interleaving
search}, which is known to be complete.
\textsc{miniKanren} is designed as a shallow DSL which may help to equip the host language with a logical reasoning features. This
design choice was proven to be applicable in practice, and there are more than 100 implementations for almost 50 languages.

The introductory book on \textsc{miniKanren}~\cite{TRS} describes the language by means of an evolving set of examples. In the
series of follow-up papers~\cite{MicroKanren,CKanren,CKanren1,AlphaKanren,2016,Guided} various extensions of the language were presented with
their semantics explained in terms of \textsc{Scheme} implementation. We argue that this style of semantic definition is
fragile and not self-sufficient since it relies on concrete implementation language semantics and therefore is not stable under the host language replacement.
In addition, the justification of important properties of relational programs (for example, refutational completeness~\cite{WillThesis}) becomes cumbersome.

There were some previous attempts to define a formal semantics for \textsc{miniKanren}. In~\cite{MechanisingMiniKanren} formal definitions
for denotational and non-deterministic operational semantics were given and the soundness result was proven; the development was mechanized in HOL. 
\cite{RelConversion} presented a variant of nondeterministic operational semantics, and~\cite{DivTest} used another variant of finite-set semantics.
None of the previous approaches were capable of reflecting the distinctive property of \textsc{miniKanren} search~--- \emph{interleaving}~\cite{Search},
thus deviating from the conventional understanding of the language.

%Moreover, one of the most important features of the language~--- the completeness of the search,~--- was never addressed.

In this paper, we present a formal semantics for core \textsc{miniKanren} and prove some of its basic properties. First,
we define denotational semantics similar to the least Herbrand model for definite logic programs~\cite{LHM}; then
we describe operational semantics with interleaving in terms of a labeled transition system. Finally, we prove the soundness and
completeness of the operational semantics w.r.t the denotational one. We support our development with a formal specification
using \textsc{Coq}~\cite{Coq} proof assistant, thus outsourcing the burden of proof checking to the automatic tool and
deriving a certified reference interpreter via extraction mechanism. As a rather straightforward extension of our
main result, we also provide a certified operational semantics (and a reference interpreter) for SLD resolution with cut, a new result
to our knowledge; while this step brings us out of purely relational domain, it still can be interesting on its own.


The paper organized as follows. In Section~\ref{language} we give the syntax of the language, describe its semantics
informally and discuss some examples. Section~\ref{denotational} contains the description of the denotational semantics for
the language, and Section~\ref{operational}~--- the operational semantics. In Section~\ref{equivalence} we overview the
certified proof for soundness and completeness of operational semantics. Section~\ref{applications} presents some applications of
the previous development, including the certified semantics for SLD resolution with cut. The second to the last section
surveys related works; the final section concludes.
