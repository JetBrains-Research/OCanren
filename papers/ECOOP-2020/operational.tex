\section{Operational Semantics}
\label{operational}

In this section we describe the operational semantics of \textsc{miniKanren}, which corresponds to the known
implementations with interleaving search. The semantics is given in the form of a labeled transition system (LTS). From now on we
assume the set of semantic variables to be linearly ordered ($\mathcal{A}=\{\alpha_1,\alpha_2,\dots\}$).

We introduce the notion of substitution

\[
  \sigma : \mathcal{A}\to\mathcal{T_A}
\]

as a (partial) mapping from semantic variables to terms over the set of semantic variables. We denote $\Sigma$ the
set of all substitutions, $\dom{\sigma}$~--- the domain for a substitution $\sigma$,
$\ran{\sigma}=\bigcup_{\alpha\in\mathcal{D}om\,(\sigma)}\fv{\sigma\,(\alpha)}$~--- its range (the set of all free variables in the image).

The states in the transition system have the following shape:

\[
S = \mathcal{G}\times\Sigma\times\mathbb{N}\mid S\oplus S \mid S \otimes \mathcal{G}
\]

As we will see later, an evaluation of a goal is separated into elementary steps, and these steps are performed interchangeably for different subgoals. 
Thus, a state has a tree-like structure with intermediate nodes corresponding to partially-evaluated conjunctions (``$\otimes$'') or
disjunctions (``$\oplus$''). A leaf in the form $\inbr{g, \sigma, n}$ determines a goal in a context, where $g$~--- a goal, $\sigma$~--- a substitution accumulated so far,
and $n$~--- a natural number, which corresponds to a number of semantic variables used to this point. For a conjunction node, its right child is always a goal since
it cannot be evaluated unless some result is provided by the left conjunct.

We also need extended states

\[
\overline{S} = \diamond \mid S
\]

where $\diamond$ symbolizes the end of evaluation, and the following well-formedness condition:

\begin{definition}
  Well-formedness condition for extended states:
  
  \begin{itemize}
  \item $\diamond$ is well-formed;
  \item $\inbr{g, \sigma, n}$ is well-formed iff $\fv{g}\cup\dom{\sigma}\cup\ran{\sigma}\subset\{\alpha_1,\dots,\alpha_n\}$;
  \item $s_1\oplus s_2$ is well-formed iff $s_1$ and $s_2$ well-formed;
  \item $s\otimes g$ is well-formed iff $s$ is well-formed and for all leaf triplets $\inbr{\_,\_,n}$ in $s$ $\fv{g}\subseteq\{\alpha_1,\dots,\alpha_n\}$.
  \end{itemize}
  
\end{definition}

Informally the well-formedness restricts the set of states to those in which all goals use only allocated variables.

Finally, we define the set of labels:

\[
L = \circ \mid \Sigma\times \mathbb{N}
\]

The label ``$\circ$'' is used to mark those steps which do not provide an answer; otherwise, a transition is labeled by a pair of a substitution and a number of allocated
variables. The substitution is one of the answers, and the number is threaded through the derivation to keep track of allocated variables; we ignore it in further explanations.

\begin{figure*}
  \renewcommand{\arraystretch}{1.6}
  \[
  \begin{array}{cr}
    \inbr{t_1 \equiv t_2, \sigma, n} \xrightarrow{\circ} \Diamond , \, \, \nexists\; mgu\,(t_1 \sigma, t_2 \sigma) &\ruleno{UnifyFail} \\
    \inbr{t_1 \equiv t_2, \sigma, n} \xrightarrow{(mgu\,(t_1 \sigma, t_2 \sigma) \circ \sigma),\, n)} \Diamond & \ruleno{UnifySuccess} \\
    \inbr{g_1 \lor g_2, \sigma, n} \xrightarrow{\circ} \inbr{g_1, \sigma, n} \oplus \inbr{g_2, \sigma, n} & \ruleno{Disj} \\
    \inbr{g_1 \land g_2, \sigma, n} \xrightarrow{\circ} \inbr{ g_1, \sigma, n} \otimes g_2 & \ruleno{Conj} \\
    \inbr{\mbox{\lstinline|fresh|}\, x\, .\, g, \sigma, n} \xrightarrow{\circ} \inbr{g\,[\bigslant{\alpha_{n + 1}}{x}], \sigma, n + 1} & \ruleno{Fresh} \\
    \dfrac{R_i^{k_i}=\lambda\,x_1\dots x_{k_i}\,.\,g}{\inbr{R_i^{k_i}\,(t_1,\dots,t_{k_i}),\sigma,n} \xrightarrow{\circ} \inbr{g\,[\bigslant{t_1}{x_1}\dots\bigslant{t_{k_i}}{x_{k_i}}], \sigma, n}} & \ruleno{Invoke}\\
    \dfrac{s_1 \xrightarrow{\circ} \Diamond}{(s_1 \oplus s_2) \xrightarrow{\circ} s_2} & \ruleno{DisjStop}\\
    \dfrac{s_1 \xrightarrow{r} \Diamond}{(s_1 \oplus s_2) \xrightarrow{r} s_2} & \ruleno{DisjStopAns}\\
    \dfrac{s \xrightarrow{\circ} \Diamond}{(s \otimes g) \xrightarrow{\circ} \Diamond} &\ruleno{ConjStop}\\
    \dfrac{s \xrightarrow{(\sigma, n)} \Diamond}{(s \otimes g) \xrightarrow{\circ} \inbr{g, \sigma, n}}  & \ruleno{ConjStopAns}\\
    \dfrac{s_1 \xrightarrow{\circ} s'_1}{(s_1 \oplus s_2) \xrightarrow{\circ} (s_2 \oplus s'_1)} &\ruleno{DisjStep}\\
    \dfrac{s_1 \xrightarrow{r} s'_1}{(s_1 \oplus s_2) \xrightarrow{r} (s_2 \oplus s'_1)} &\ruleno{DisjStepAns}\\
    \dfrac{s \xrightarrow{\circ} s'}{(s \otimes g) \xrightarrow{\circ} (s' \otimes g)} &\ruleno{ConjStep}\\
    \dfrac{s \xrightarrow{(\sigma, n)} s'}{(s \otimes g) \xrightarrow{\circ} (\inbr{g, \sigma, n} \oplus (s' \otimes g))} & \ruleno{ConjStepAns} 
  \end{array}
  \]
  \caption{Operational semantics of interleaving search}
  \label{lts}
\end{figure*}

The transition rules are shown in Figure~\ref{lts}. The first two rules specify the semantics of unification. If two terms are not unifiable under the current substitution
$\sigma$ then the evaluation stops with no answer; otherwise, it stops with the answer equal to the most general unifier.

The next two rules describe the steps performed when disjunction or conjunction is encountered on the top level of the current goal. For disjunction, it schedules both goals (using ``$\oplus$'') for
evaluating in the same context as the parent state, for conjunction~--- schedules the left goal and postpones the right one (using ``$\otimes$'').

The rule for ``\lstinline|fresh|'' substitutes bound syntactic variable with a newly allocated semantic one and proceeds with the goal; no answer provided at this step.

The rule for relation invocation finds a corresponding definition, substitutes its formal parameters with the actual ones, and proceeds with the body.

The rest of the rules specify the steps performed during the evaluation of two remaining types of the states~--- conjunction and disjunction. In all cases, the left state
is evaluated first. If its evaluation stops with a result then the right state (or goal) is scheduled for evaluation, and the label is propagated. If there is no result then
the conjunction evaluation stops with no result (\textsc{ConjStop}) as well while the disjunction evaluation proceeds with the right state (\textsc{DisjStop}).

The last four rules describe \emph{interleaving}, which occurs when the evaluation of the left state suspends with some residual state (with or without an answer). In the case of disjunction
the answer (if any) is propagated, and the constituents of the disjunction are swapped (\textsc{DisjStep}, \textsc{DisjStepAns}). In case of conjunction, if the evaluation step in
the left conjunct did not provide any answer, the evaluation is continued in the same order since there is still no information to proceed with the evaluation of the right
conjunct (\textsc{ConjStep}); if there is some answer, then the disjunction of the right conjunct in the context of the answer and the remaining conjunction is
scheduled for evaluation (\textsc{ConjStepAns}).

The introduced transition system is completely deterministic. There was, however, some freedom in choosing the order of evaluation for conjunction and
disjunction states. For example, instead of evaluating the left substate first we could choose to evaluate the right one, etc. In each concrete case we would
end up with a different (but still deterministic) system that would prescribe different semantics to a concrete goal. This choice reflects the inherent
non-deterministic nature of search in relational (and, more generally, logical) programming. However, as long as deterministic search procedures
are sound and complete, we can consider them ``equivalent''\footnote{There still can be differences in observable behavior of concrete goals under different
sound and complete search strategies: a goal can be refutationally complete~\cite{WillThesis} under one strategy and non-complete under another.}.

A derivation sequence for a certain state determines a \emph{trace}~--- a finite or infinite sequence of answers. The trace corresponds to the stream of answers
in the reference \textsc{miniKanren} implementations.

To formalize the operational part in \textsc{Coq} we first need to define all preliminary notions from unification theory~\cite{Unification} which our semantics uses.

In particular, we need to implement the notion of the most general unifier (MGU). As it is well-known~\cite{UnificationMcBride} all standard recursive algorithms for calculating
MGU are not decreasing on argument terms, so we can't define them as simple recursive functions in \textsc{Coq} due to the termination check failure. There is no such obstacle
when we define MGU as a proposition:

\begin{lstlisting}[language=Coq]
  Inductive mgu :
    term -> term -> option subst -> Set := ...
\end{lstlisting}

However, we still need to use a well-founded induction to prove the existence of the most general unifier and its defining properties:\\[5mm]

\begin{lstlisting}[language=Coq]
  Lemma mgu_$\texttt{exists}$ : forall t1 t2, {r & mgu t1 t2 r}.
  Definition unifier (s : subst) (t1 t2 : term) : Prop :=
    apply_subst s t1 = apply_subst s t2.
  Lemma mgu_unifies:
    forall t1 t2 s, mgu t1 t2 (Some s) -> unifier s t1 t2.
  Definition more_general (m s : subst) : Prop :=
    exists (s' : subst),
    forall (t : term),
      apply_subst s t = apply_subst s' (apply_subst m t).
  Lemma mgu_most_general :
    forall (t1 t2 : term)
      (m : subst),
      mgu t1 t2 (Some m) ->
      forall (s : subst),
        unifier s t1 t2 -> more_general m s.
  Lemma mgu_non_unifiable :
    forall (t1 t2 : term),
      mgu t1 t2 None -> forall s,  ~ (unifier s t1 t2).
\end{lstlisting}

For this well-founded induction we use the number of distinct free variables in argument terms as a well-founded order on pairs of terms.

\begin{comment}
For this well-founded induction we use the number of free variables in argument terms as a well-founded order on pairs of terms:

\begin{lstlisting}[language=Coq]
  Definition terms := term * term.
  Definition fvOrder (t : terms) :=
    length (union (fv_term (fst t)) (fv_term (snd t))).
  Definition fvOrderRel (t p : terms) :=
    fvOrder t < fvOrder p.
  Lemma fvOrder_wf : well_founded fvOrderRel.
\end{lstlisting}
\end{comment}

After this preliminary work, the described transition relation can be encoded naturally as an inductively defined proposition (here ``\lstinline|state'|''
stands for a non-extended state and ``\lstinline|state|'' --- for an extended one):

\begin{lstlisting}[language=Coq]
  Inductive eval_step :
    state' -> label -> state -> Set := ...
\end{lstlisting}

We state the fact that our system is deterministic through the existence and uniqueness of a transition for every state:

\begin{lstlisting}[language=Coq]
  Lemma eval_step_$\texttt{exists}$ :
    forall (st' : state'),
    {l : label & {st : state & eval_step st' l st}}.
  Lemma eval_step_unique :
    forall (st' : state')
      (l1 l2 : label)
      (st1 st2 : state'),
    eval_step st' l1 st1 ->
    eval_step st' l2 st2 ->
    l1 = l2 /\ st1 = st2.
\end{lstlisting}

To work with (possibly) infinite sequences we use the standard approach in \textsc{Coq}~--- coinductively defined streams:

\begin{lstlisting}[language=Coq]
  Context {A : Set}.

  CoInductive stream : Set :=
  | Nil : stream
  | Cons : A -> stream -> stream.
\end{lstlisting}

Although the definition of the datatype is coinductive some of its properties we are working with make sense only when defined inductively:

\begin{lstlisting}[language=Coq]
  Inductive in_stream : A -> stream -> Prop :=
  | inHead : forall x t,
    in_stream x (Cons x t)
  | inTail : forall x h t,
    in_stream x t -> in_stream x (Cons h t).
  Inductive finite : stream -> Prop :=
  | fNil : finite Nil
  | fCons : forall h t, finite t -> finite (Cons h t).
\end{lstlisting}

Then we define a trace coinductively as a stream of labels in transition steps and prove that there exists a unique trace from any extended state:

\begin{lstlisting}[language=Coq]
  Definition trace : Set := $@$stream label.
  CoInductive op_sem : state -> trace -> Set :=
  | osStop : op_sem Stop Nil
  | osState : forall st' l st t,
      eval_step st' l st ->
      op_sem st t ->
      op_sem (State st') (Cons l t).
  Lemma op_sem_$\texttt{exists}$ (st : state):
    {t : trace & op_sem st t}.
  Lemma op_sem_unique:
    forall st t1 t2,
      op_sem st t1 ->
      op_sem st t2 ->
      equal_streams t1 t2.
\end{lstlisting}

Note, for the equality of streams we need to define a new coinductive proposition instead of using the standard syntactic equality in order for coinductive proofs to work~\cite{CPDT}.

One thing we can prove using operational semantics is the \emph{interleaving} properties of disjunction. Specifically, we can prove that a trace for a disjunction is
a one-by-one interleaving of streams for its disjuncts:

\begin{lstlisting}[language=Coq]
  CoInductive interleave :
    stream -> stream -> stream -> Prop :=
  | interNil : forall s s',
    equal_streams s s' -> interleave Nil s s'
  | interCons : forall h t s rs,
    interleave s t rs ->
    interleave (Cons h t) s (Cons h rs).
  Lemma sum_op_sem : forall st1 st2 t1 t2 t,
    op_sem (State st1) t1 ->
    op_sem (State st2) t2 ->
    op_sem (State (Sum st1 st2)) t ->
    interleave t1 t2 t.
\end{lstlisting}

This allows us to prove the expected properties of interleaving in a more general setting of arbitrary streams.

\begin{comment}
\begin{itemize}
\item the elements of the interleaved stream are exactly those of two interleaved streams;
\item the interleaved stream is finite iff both interleaving streams are finite.
\end{itemize}
\end{comment}

{\color{blue}
\begin{lemma}
\label{InterleavingInLemma}
For any streams $s_1$, $s_2$, $s$ satisfying $\mbox{\lstinline|interleave s1 s2 s|}$,
the elements occuring in $s$ are exactly the elements occuring in $s_1$ or $s_2$.
\end{lemma}

\begin{lemma}
\label{InterleavingFiniteLemma}
For any streams $s_1$, $s_2$, $s$ satisfying $\mbox{\lstinline|interleave s1 s2 s|}$,
$s$ is finite iff $s_1$ is finite and $s_2$ is finite.
\end{lemma}
}

\begin{comment}
The corresponding \textsc{Coq} lemmas are as follows:

\begin{lstlisting}[language=Coq]
  Lemma interleave_in : forall s1 s2 s,
    interleave s1 s2 s ->
    forall x, in_stream x s <-> in_stream x s1 \/ in_stream x s2.
  Lemma interleave_finite : forall s1 s2 s,
    interleave s1 s2 s ->
    (finite s <-> finite s1 /\ finite s2).
\end{lstlisting}
\end{comment}

One immediate corollary of these facts is the ``commutativity'' of disjunction under the interleaving search: the fact that swapping two disjuncts (at the top level) does not change the termination of the goal evaluation.
