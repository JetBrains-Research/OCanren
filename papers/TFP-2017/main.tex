\documentclass{llncs}

\usepackage{makeidx}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{url}

\sloppy

\def\transarrow{\xrightarrow}
\newcommand{\setarrow}[1]{\def\transarrow{#1}}

\newcommand{\trule}[2]{\frac{#1}{#2}}
\newcommand{\crule}[3]{\frac{#1}{#2},\;{#3}}
\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\trans}[3]{{#1}\transarrow{#2}{#3}}
\newcommand{\ctrans}[4]{{#1}\transarrow{#2}{#3},\;{#4}}
\newcommand{\llang}[1]{\mbox{\lstinline[mathescape]|#1|}}
\newcommand{\pair}[2]{\inbr{{#1}\mid{#2}}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\highlight}[1]{\color{red}{#1}}
\newcommand{\ruleno}[1]{\eqno[\textsc{#1}]}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\lfp}[1]{fix_{#1}}
\newcommand{\gfp}[1]{Fix_{#1}}
\newcommand{\vsep}{\vspace{-2mm}}
\newcommand{\supp}[1]{\scriptsize{#1}}

\lstdefinelanguage{ocanren}{
keywords={fresh, let, in, match, with, when, class,
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={->}{{$\to\;\;$}}3 {===}{{$\equiv$}}3 {=/=}{{$\not\equiv$}}3 {|>}{{$\triangleright$}}3,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocanren
}

\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}

\begin{document}

\mainmatter

\title{Relational Conversion of High-Order Typed Programs}

\author{
  Petr Lozov\inst{1} \and Andrei Vyatkin\inst{2} \and Dmitry Boulytchev\inst{3}
}

\institute{
St.Petersburg State University\\
Universitetski pr., 28, 198504, St.Petersburg, Russia\\
JetBrains Research\\
\email{lozov.peter@gmail.com}
\and
St.Petersburg State University\\
Universitetski pr., 28, 198504, St.Petersburg, Russia\\
\email{dewshick@gmail.com}
\and
St.Petersburg State University\\
Universitetski pr., 28, 198504, St.Petersburg, Russia\\
JetBrains Research\\
\email{dboulytchev@math.spbu.ru}
}

\maketitle

\begin{abstract}
Some abstract
\end{abstract}

\section{Test}

\begin{figure}
\centering
Supplementary syntax categories:
$$
\begin{array}{rcll}
  \mathcal C &=&\lstinline|True|,\,\lstinline|False|,\,C^n,\dots                &\mbox{\supp(constructors with arity)}\\
  \mathcal X &=&x,\,y,\,z,\,\dots                                               &\mbox{\supp(variables)}\\
  \mathcal P &=&C^n\,(x_1,\,\dots,\,x_n)                                         &\mbox{\supp(shallow patterns)}
\end{array}
$$
Expressions:
$$
\begin{array}{rcll}
  \mathcal E &=&x                                                               &\mbox{\supp(variable occurrence)}\\
             & &\lambda x.e                                                     &\mbox{\supp(abstraction)}\\
             & &e_1\;e_2                                                        &\mbox{\supp(application)}\\ 
             & &C^n\,e_1\ldots e_n                                              &\mbox{\supp(constructor application)}\\
             & &\lstinline|let $x$ = $e_1$ in $e_2$|                            &\mbox{\supp(let-binding)}\\
             & &\lstinline|let rec $f$ = $\lambda x.e_1$ in $e_2$|              &\mbox{\supp(recursive let-binding)}\\
             & &e_1\,=\,e_2                                                     &\mbox{\supp(equality test)}\\
             & &\lstinline|match $e$ with $\{p_i$ -> $e_i\}$| &\mbox{\supp(pattern matching)}
\end{array}
$$
\caption{Syntax of the source language}
\label{functional_syntax}
\end{figure}

\setarrow{:}
\newcommand{\typed}[3]{\withenv{#1}{\trans{#2}{}{#3}}}

\begin{figure}
\centering
Types:
$$
\begin{array}{rcll}
  \mathcal X &=&\alpha, \beta, \dots                                           &\mbox{\supp{(type variables)}}\\
  \mathcal D &=&T^n,...                                                         &\mbox{\supp{(datatype constructors)}}\\
  \mathcal T &=&\lstinline|bool|\mid\alpha\mid T^n(t_1,\dots,t_n)\mid t_1\to t_2 &\mbox{\supp{(types)}}\\
  \mathcal S &=&\forall\bar{\alpha}.t                                          &\mbox{\supp{(type schemas)}}
\end{array}
$$
Typing rules:

$$
\typed{\Gamma}{\lstinline|True|,\;\lstinline|False|}{\lstinline|bool|}
\ruleno{Bool$_T$}
$$

$$
\trule{\typed{\Gamma}{e_1}{t}\;\;\;\;\typed{\Gamma}{e_2}{t}}
      {\typed{\Gamma}{e_1=e_2}{\lstinline|bool|}}
\ruleno{Eq$_T$}
$$

$$
\trule{\typed{\Gamma}{e_i}{t^C_i}}
      {\typed{\Gamma}{C^n(e_1,\dots,e_n)}{t^C}}
\ruleno{Constr$_T$}
$$

$$
\typed{\Gamma,x:\forall\bar{\alpha}.t}{x}{t[\bar{\alpha}\gets\bar{t^\prime}]}
\ruleno{Var$_T$}
$$

$$
\trule{\typed{\Gamma}{f}{t_1\to t_2}\;\;\;\;\typed{\Gamma}{e}{t_1}}
      {\typed{\Gamma}{f\;e}{t_2}}
\ruleno{App$_T$}
$$

$$
\trule{\typed{\Gamma,\,x:t_1}{f}{t_2}}
      {\typed{\Gamma}{\lambda x.f}{t_1\to t_2}}
\ruleno{Abs$_T$}
$$

$$
\trule{\typed{\Gamma}{e_1}{t_1}\;\;\;\;\typed{\Gamma,x:\forall\bar{\alpha}.t_1}{e_2}{t}}
      {\typed{\Gamma}{\lstinline|let $\;x\;$ = $\;e_1\;$ in $\;e_2$|}{t}},\;\bar{\alpha}=FV(t_1)\setminus FV(\Gamma)
\ruleno{Let$_T$}
$$

$$
\trule{\typed{\Gamma,f:t_1}{\lambda x.e_1}{t_1}\;\;\;\;\typed{\Gamma,f:\forall\bar{\alpha}.t_1}{e_2}{t}}
      {\typed{\Gamma}{\lstinline|let rec $\;f\;$ = $\;\lambda x.e_1\;$ in $\;e_2$|}{t}},\;\bar{\alpha}=FV(t_1)\setminus FV(\Gamma)
\ruleno{LetRec$_T$}
$$

$$
\trule{\typed{\Gamma}{e}{t^C}\;\;\;\;\typed{\Gamma,x^i_1:t^{C_i}_1,\dots,x^i_{k_i}:t^{C_i}_{k_i}}{e_i}{t}}
      {\typed{\Gamma}{\lstinline|match $\;e\;$ with $\;\{C_i^{k_i}(x^i_1,\dots,x^i_{k_i})$ -> $e_i\}$|}{t}}
\ruleno{Match$_T$}
$$
\caption{Typing rules for the source language}
\label{functional_typing}
\end{figure}

\setarrow{\to}
\newcommand{\step}[2]{\trans{\inbr{#1}}{}{\inbr{#2}}}

\begin{figure}
\centering
Values:
$$
\mathcal V = \lstinline|True|\mid\lstinline|False|\mid C^n(v_1,\dots,v_n)\mid\lambda x.e
$$
Contexts:
$$
\mathcal C = \Box\mid\Box\;e\mid v\;\Box\mid\lstinline|let $x$ = $\Box$ in $e$|\mid\lstinline|match $\;\Box\;$ with $\{p_i$->$e_i\}$|\mid C^n(v_1,\dots,v_{k-1},\Box,e_{k+1},\dots,e_n)\mid\Box=e\mid v=\Box 
$$
$$
C[e]\mbox{~--- a context $C$ with an expression $e$ plugged into a hole}
$$
Stack of contexts:
$$
\mathcal S=\epsilon\mid\mathcal C : \mathcal S
$$
Transitions:
$$
\step{C:\mathcal S,\, v}{\mathcal S,\, C[v]}
$$
$$
\step{\mathcal S,\,e_1=e_2}{\Box=e_2:\mathcal S,\,e_1}
$$
$$
\step{\mathcal S,\,v=e}{v=\Box:\mathcal S,\,e}
$$
$$
\step{C:\mathcal S,\,v=v}{\mathcal S,\,C[True]}
$$
$$
\step{C:\mathcal S,\,v_1=v_2}{\mathcal S,\,C[False]},\;v_1\ne v_2
$$
$$
\step{\mathcal S,\, f\;e}{\Box\;e:\mathcal S,\, f}
$$
$$
\step{\mathcal S,\, (\lambda x.e_1)\;e_2}{(\lambda x.e_1)\;\Box:\mathcal S,\, e_2}
$$
$$
\step{\mathcal S,\, (\lambda x.e)\;v}{\mathcal S,\, e[x\gets v]}
$$
$$
\step{\mathcal S,\, (\mu f\lambda x.e_1)\;e_2}{(\mu f\lambda x.e_1)\;\Box:\mathcal S,\, e_2}
$$
$$
\step{\mathcal S,\, (\mu f\lambda x.e)\;v}{\mathcal S,\, e[f\gets\mu f\lambda x.e,\, x\gets v]}
$$
$$
\step{\mathcal S,\, C^n(v_1,\dots,v_{k-1},e_k,\dots,e_n)}{C^n(v_1,\dots,v_{k-1},\Box,\dots,e_n):\mathcal S,\, e_k}
$$
$$
\step{\mathcal S,\, \lstinline|let $\;x\;$ = $\;e_1\;$ in $\;e_2$|}{\lstinline|let $\;x\;$ = $\;\Box\;$ in $\;e_2$|:\mathcal S,\, e_1}
$$
$$
\step{\mathcal S,\, \lstinline|let $\;x\;$ = $\;v\;$ in $\;e$|}{\mathcal S,\,e[x\gets v]}
$$
$$
\step{\mathcal S,\, \lstinline|let rec $\;f\;$ = $\;\lambda x.e_1\;$ in $\;e_2$|}{\mathcal S,\, e_2[f\gets\mu f\lambda x.e_1]}
$$
$$
\step{\mathcal S,\,\lstinline|match $\;e\;$ with $\;\{p_i$->$e_i\}$|}{\lstinline|match $\;\Box\;$ with $\;\{p_i$->$e_i\}$|:\mathcal S,\, e}
$$
$$
\step{\mathcal S,\,\lstinline|match $\;C_k^{n_k}(v_1,\dots,v_{n_k})\;$ with $\;\{C_i^{n_i}(x^i_1,\dots,x^i_{n_i})$->$e_i\}$|}{\mathcal S,\,e_k[x^k_1\gets v_1,\dots,x^k_{n_k}\gets v_n]}
$$
\caption{Semantics of the source language}
\label{functional_semantics}
\end{figure}

\begin{thebibliography}{99}
\bibitem{TRS}
Daniel P. Friedman, William E.Byrd, Oleg Kiselyov. The Reasoned Schemer. The MIT
Press, 2005.

\bibitem{MicroKanren}
Jason Hemann, Daniel P. Friedman. $\mu$Kanren: A Minimal Core for Relational Programming //
Proceedings of the 2013 Workshop on Scheme and Functional Programming (Scheme '13).

\bibitem{CKanren}
Claire E. Alvis, Jeremiah J. Willcock, Kyle M. Carter, William E. Byrd, Daniel P. Friedman.
cKanren: miniKanren with Constraints //
Proceedings of the 2011 Workshop on Scheme and Functional Programming (Scheme '11).

\bibitem{Untagged}
William E. Byrd, Eric Holk, Daniel P. Friedman.
miniKanren, Live and Untagged: Quine Generation via Relational Interpreters (Programming Pearl) //
Proceedings of the 2012 Workshop on Scheme and Functional Programming (Scheme '12).

\bibitem{Implicits}
Leo White, Fr\'ed\'eric Bour, Jeremy Yallop.
Modular Implicits // Workshop on ML, 2014, arXiv:1512.01438.

\bibitem{Unparsing}
Olivier Danvy.
Functional Unparsing // Journal of Functional Programming, Vol.~8, Issue~6, November 1998.

\bibitem{DoWeNeed}
Daniel Fridlender, Mia Indrika.
Do we need dependent types? // Journal of Functional Programming, Vol.~10, Issue~4, July 2000.

\bibitem{DGP}
Jeremy Gibbons. Datatype-generic Programming //
Proceedings of the 2006 International Conference on Datatype-generic Programming.

\bibitem{Deriving}
Jeremy Yallop.
Practical Generic Programming in OCaml // Proceedings of 2007 Workshop on ML.

\bibitem{InstantGenerics}
Manuel M. T. Chakravarty, Gabriel C. Ditu, Roman Leshchinskiy.
Instant Generics: Fast and Easy. \url{http://www.cse.unsw.edu.au/~chak/papers/CDL09.html}, 2009.

\bibitem{ALaCarte}
Wouter Swierstra. Data Types \'a la Carte  // Journal of Functional Programming, Vol.~18, Issue~4, 2008.

\bibitem{Kumar}
Ramana Kumar. Mechanising Aspects of miniKanren in HOL. Bachelor Thesis, The Australian National University, 2010.

\bibitem{Unification}
Franz Baader, Wayne Snyder. Uniﬁcation theory. In John Alan Robinsonand Andrei Voronkov, editors,
Handbook of Automated Reasoning. Elsevier and MIT Press, 2001.

\bibitem{triangular}
David C Bender, Lindsey Kuper, William E Byrd, Daniel P Friedman.
Efficient Representations for Triangular Substitutions: a Comparison in miniKanren. Indiana University, 2009.

\bibitem{HKinded}
Jeremy Yallop, Leo White. Lightweight Higher-Kinded Polymorphism. FLOPS 2014.

\bibitem{Lambda}
Henk Barendregt. Lambda Calculi with Types, Handbook of Logic in Computer Science (Vol.~2), 1992.

\bibitem{WillThesis}
William E. Byrd. Relational Programming in miniKanren: Techniques, Applications, and Implementations. PhD Thesis,
Indiana University, Bloomington, IN, September 30, 2009.
\end{thebibliography}

\end{document}

