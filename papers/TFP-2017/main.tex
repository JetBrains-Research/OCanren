\documentclass{llncs}

\usepackage{makeidx}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{xcolor}
\usepackage{url}
\usepackage{stmaryrd}
\usepackage{xspace}
\usepackage{comment}
\usepackage{wrapfig}
\usepackage{placeins}
\usepackage{tabularx}
\usepackage{ragged2e}
\usepackage{natbib}

%\usepackage [sorting = none] {biblatex}

%\addbibresource {main.bib}

\def\transarrow{\xrightarrow}
\newcommand{\setarrow}[1]{\def\transarrow{#1}}

\newcommand{\trule}[2]{\frac{#1}{#2}}
\newcommand{\crule}[3]{\frac{#1}{#2},\;{#3}}
\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\trans}[3]{{#1}\transarrow{#2}{#3}}
\newcommand{\ctrans}[4]{{#1}\transarrow{#2}{#3},\;{#4}}
\newcommand{\llang}[1]{\mbox{\lstinline[mathescape]|#1|}}
\newcommand{\pair}[2]{\inbr{{#1}\mid{#2}}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\highlight}[1]{\color{red}{#1}}
\newcommand{\ruleno}[1]{\eqno[\scriptsize\textsc{#1}]}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\lfp}[1]{fix_{#1}}
\newcommand{\gfp}[1]{Fix_{#1}}
\newcommand{\vsep}{\vspace{-2mm}}
\newcommand{\supp}[1]{\scriptsize{#1}}
\newcommand{\G}{\mathfrak G}
\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\miniKanren}{miniKanren\xspace}
\newcommand{\ocanren}{OCanren\xspace}
\newcommand{\free}[1]{\boxed{#1}}
\newcommand{\binds}{\;\mapsto\;}
\newcommand{\dbi}[1]{\mbox{\bf{#1}}}

\let\emptyset\varnothing

\lstdefinelanguage{ocanren}{
keywords={fresh, let, in, match, with, when, class, type,
object, method, of, rec, repeat, until, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, success, failure,
true, false},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {|||}{{$\vee$}}2 {/\\}{{$\wedge$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
%basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocanren
}

\usepackage{letltxmacro}
\newcommand*{\SavedLstInline}{}
\LetLtxMacro\SavedLstInline\lstinline
\DeclareRobustCommand*{\lstinline}{%
  \ifmmode
    \let\SavedBGroup\bgroup
    \def\bgroup{%
      \let\bgroup\SavedBGroup
      \hbox\bgroup
    }%
  \fi
  \SavedLstInline
}
\addtolength{\parskip}{-2pt}

\begin{document}
\sloppy
\mainmatter

\title{Typed Relational Conversion}

\author{
  Petr Lozov \and Andrei Vyatkin \and Dmitry Boulytchev
}

\institute{
St.Petersburg State University\\
Universitetski pr., 28, 198504, St.Petersburg, Russia\\
JetBrains Research\\
Universitetskaya emb., 7-9-11, bldg. 5A, 199034, St.Petersburg, Russia}

\maketitle

\begin{abstract}
We address the problem of transforming typed functional programs into relational form. 
In this form a program can be run in various ``directions'' with some arguments left free, 
making it possible to acquire different behaviors from a single specification. We specify the 
syntax, typing rules and semantics for the source language as well as its relational extension, 
describe the conversion and prove its correctness both in terms of typing and dynamic semantics. 
We also discuss the limitations of our approach, present the implementation of the conversion for 
the subset of OCaml and evaluate it on a number of realistic examples.
\end{abstract}

\input{introduction.tex}
\input{ocanren.tex}
\input{language.tex}
\input{conversion.tex}
\input{evaluation.tex}
\input{conclusion.tex}

\bibliographystyle{abbrv}
\bibliography{main}
%\printbibliography

\end{document}

