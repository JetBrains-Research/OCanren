\section{The Angelic Semantics}
\label{sec:angelic-semantics}

В данном разделе мы представляем операционную ангельскую семантику языка \mk. Вместо постулирования определенного порядка вычисления коннъюнктов данная семантика недетерминированно рассматривает всевозможные порядки вычисления. Отметим, что на данный момент существуют операционные семантики языка \mk~\cite{fair:conversion,fair:semantics}, однако они все они вычисляют конъюнкты слева направо (left-bias).

Семантика, которую мы предлагаем, основана на развертке вызовов отношений. На каждом шаге в текущем состоянии программы выбирается произвольный вызов, который разворачивается. Этот процесс продолжается, пока в текущем состоянии остаются вызовы. Если на каком-то шаге состояние опустело, то вычисление сошлось. В противном случае вычисление расходится.

Прежде всего мы определим множество состояний исполнения реляционной программы:

\[
\begin{array}{rcll}
  c & = & R_i^{k_i}(\mathcal{T}_\mathcal{X}^1, \ldots, \mathcal{T}_\mathcal{X}^{k_i}) & \mbox{calls} \\
  C & = & \epsilon \mid c_1 \land \dots \land c_n  & \mbox{conjunction of calls} \\
  \textgoth{T} & = & \textgoth{T} \lor \textgoth{T} & \mbox{disjunction state} \\
               & \mid & \inbr{\sigma;\, i;\, C} & \mbox{leaf state}\\[1mm]
\end{array}
\]


Это состояние является деревом дизъюнкций. Внутренние узел ``$\lor$'' соотвествует дизъюнкции двух состояний-потомков. Его листья содержат промежуточные подстановки, индекс семантических переменных $i$, и список вызовов. Подстановка --- это отображение из семантических переменных в семантические термы. Оно содержит информацию о текущих переменных и обновляется при исполнении унификаций. Индекс семантических переменных необходим для исполнения операции \lstinline|fresh|, которая вводит семантическую переменную с новым индексом. Список вызовов содержит вызовы отношений $c_i$, которые необходимо довычислить в этой ветке. Число вызовов может равняться нулю, чему соотвествует список $\epsilon$.

Мы расширим множество состояний пустым состоянием,

\[
\textgoth{T} += \emptyset
\]

\noindent которое соотвествует завершению вычисления.

Также мы введем две вспомогательных функции для работы с состоянием программы. Первая функция $union$ производит объединение двух состояний:
\[
union\,(T_1,\, T_2) =
\left\{
\begin{array}{rl}
T_2, & \mbox{if } T_1 = \emptyset \\
T_1, & \mbox{if } T_1 \not= \emptyset \mbox{ and } T_2 = \emptyset \\
T_1 \lor T_2, & \mbox{otherwise}.
\end{array}
\right.
\]

Если одно из состояний пустое, функция union вернёт второе. Если оба состояния не пусты, то функция вернёт объединенное состояние.

Следующая вспомогательная функция $push$ необходима для конструирования состояния после развертки:

\[
push(C, T) =
\left\{
\begin{array}{rl}
\emptyset, &  \!\!\!\mbox{if } T = \emptyset \\
\!\!\!push(C, T_1) \lor push(C, T_2), & \!\!\!\mbox{if } T = T_1 \lor T_2 \\
\inbr{\sigma;\, i;\, C_1 \land \bar{C} \land C_2}, & \!\!\!\mbox{if } T = \inbr{\sigma;\, i;\, \bar{C}} \\  & \!\!\!\mbox{ and } C \!=\! C_1\! \land\! \Box\! \land\! C_2
\end{array}
\right.
\]

Первый аргумент этой функции --- это список вызовов, который содержит \emph{дырку} ``$\Box$''. На этом месте стоял вызов, который мы развернули. Второй аргумент --- состояние, которое является результатом развертки. Данная функция рекурсивно проходит по состоянию и в каждом листе помещаяет вызовы первого аргумента на место дырки. 

Теперь мы определим семантику для операции развертки. Эта семантика (Fig.~\ref{fair:unfolding-semantics}) преобразовывает вызов отношения и подстановку в состояние, которое соответствует телу этого отношения. Так как развертка вызова --- конечный процесс, мы можем описать развертку как семантику большого шага в виде отношения ``$\Rightarrow$''.

\begin{figure}[h!]
\[\begin{array}{cr}

\dfrac{ R = \lambda \bar{x}. b \qquad \inbr{\sigma;\, i;\, \epsilon} \vdash b[\bar{x} \leftarrow \bar{t}] \leadsto T}
      {(\sigma, i) \vdash R(\bar{t}) \Rightarrow T}
&     \ruleno{Unfold} \\[4mm]
{\emptyset \vdash g \leadsto \emptyset}
&     \ruleno{Empty} \\[2mm]
\dfrac{\not\exists \, mgu(t_1, t_2, \sigma)}
      {\inbr{\sigma;\, i;\, C} \vdash (t_1 \equiv t_2) \leadsto \emptyset}
&     \ruleno{UnifyFail}  \\[4mm]
\dfrac{\bar\sigma = mgu(t_1, t_2, \sigma)}
      {\inbr{\sigma;\, i;\, C} \vdash (t_1 \equiv t_2) \leadsto \inbr{\bar\sigma;\, i;\, C}}
&     \ruleno{UnifySucc}  \\[4mm]
      {\inbr{\sigma;\, i;\, C} \vdash F(\bar{t}) \leadsto \inbr{\sigma;\, i;\,C \land R(\bar{t})}}
&     \ruleno{Call} \\[2mm]
\dfrac{\inbr{\sigma;\, i+1;\, C} \vdash g[x \leftarrow \alpha_i] \leadsto T}
      {\inbr{\sigma;\, i;\, C} \vdash \mbox{\lstinline|fresh|} (x)\, g \leadsto T}
&     \ruleno{Fresh}  \\[4mm]
\dfrac{\inbr{\sigma;\, i;\, C} \vdash g_1 \leadsto T_1 \qquad \inbr{\sigma;\, i;\, C} \vdash g_2 \leadsto T_1}
      {\inbr{\sigma;\, i;\, C} \vdash g_1 \lor g_2 \leadsto union(T_1, T_2)}
&     \ruleno{DisjGoal}  \\[4mm]
\dfrac{T_1 \vdash g \leadsto T_3 \qquad T_2 \vdash g \leadsto T_4}
      {T_1 \lor T_2 \vdash g \leadsto union(T_3, T_4)}
&     \ruleno{DisjState}  \\[4mm]
\dfrac{\inbr{\sigma;\, i;\, C} \vdash g_1 \leadsto T \qquad T \vdash g_2 \leadsto \bar{T}}
      {\inbr{\sigma;\, i;\, C} \vdash g_1 \land g_2 \leadsto \bar{T}}
&     \ruleno{Conj}
\end{array}\]

\caption{Big step semantics of unfolding}
\label{fair:unfolding-semantics}
\end{figure}

Правило [Unfold] является внешним. Поэтому оно единственное содержит символ ``$\Rightarrow$''. Оно запускает процесс развертки вызова $R$ с набором аргументов $\bar{x}$ в контексте подстановки  $\sigma$ и счетчика семантических переменных $i$. Прежде всего, вызов $R$ заменяется на $b$ --- тело отношения. Далее выполняется подстановка термов $\bar{t}$ на место переменных $\bar{x}$ и инициализируется начальное состояние $\inbr{\sigma;\, i;\, \epsilon}$. Далее запускается преобразование тела отношения в состояние с помощью оставшихся правил.

Правило \rulen{Empty} обрабатывает случай пустого состояния. Правила \rulen{UnifyFail} и \rulen{UnifySucc} исполняют унификацию. Если существует ноиболее общий унификатор (MGU), то мы применяем правило rulen{UnifySucc}, которое обновляет подстановку. Если MGU не существует, то мы применияем правило \rulen{UnifyFail}, что приводит к пустому состоянию.

Так как развертка должна развернуть вызов ровно один раз, все вложенные вызовы мы оставляем без изменений. Данное поведение описано в правиле \rulen{Call}. Вложенный вызов не вычисляется, а помещаяется в список вызовов состояния.

Правило \rulen{Fresh} соответствует введению свежей переменной. В данном правиле мы заменяем синтаксическую переменную на семантическую переменную. Также мы увеличиваем счетчик семантических переменных. 

Правила \rulen{DisjGoal} и [DisjState] необходимы для исполнения дизъюнкции. Первое правило вычисляет оба дизъюнкта и объединяет их в новое состояние с помощью вспомогательной функции union. Второе правило обрабатывает дизъюнкцию, содержащуюся в состоянии. Как и в первом правиле мы производим два независимых вычисления, а затем объединяем результаты в новое состоение.

Оставшиеся правило \rulen{Conj} описывает вычисление конъюнкции. В этом случае мы вычисляем первый конъюнкт в состояние $T$, а затем вычисляем второй конъюнкт в контесте состояния $T$. Таким образом, второй конъюнкт будет исполнен в контексте всех листьев состояния $Т$. Отметим, что, если первый конъюнкт вычислятся в пустое состояние, то мы сможем применить только правило\rulen{EmptySet} для 

Наконец, мы определим множество меток, определяющее ответы семантики:
\[
L = \circ \mid \sigma.
\]
Метка ``$\circ$'' обозначает отсутствие ответа, в противном случае ответом является подстановка.

Теперь у нас есть всё необходимое, чтобы определить недетерминированную семанику реляционного языка (Fig.~\ref{fair:classic-semantics}). Данная семантика малого шага последовательно преобразовывает состояние и периодически производит ответы, которыми являются итоговые подстановки, которые помещаются над символом перехода ``$\xrightarrow{}$''. В противном случае над символом перехода будет помещена метка ``$\circ$''.

\begin{figure}[h!]
\[\begin{array}{cr}
     {\inbr{\sigma;\, i;\, \epsilon} \xrightarrow{\sigma} \emptyset}  
&     \ruleno{Answer} \\[2mm]
\dfrac{(\sigma, i) \vdash c \Rightarrow T}
      {\inbr{\sigma;\, i;\, C_1 \land c \land C_2} \xrightarrow{\circ} push(C_1 \land \Box \land C_2, T)}
&     \ruleno{ConjUnfold} \\[4mm]
\dfrac{T_1 \xrightarrow{\alpha} \emptyset}
      {T_1 \lor T_2 \xrightarrow{\alpha} T_2}
&     \ruleno{Disj} \\[4mm]
\dfrac{T_1 \xrightarrow{\alpha} \bar{T_1} \qquad \bar{T_1} \not= \emptyset}
      {T_1 \lor T_2 \xrightarrow{\alpha} T_2 \lor\bar{T_1}}
&     \ruleno{DisjStep}
\end{array}\]
\caption{Angelic semantics of \mk}
\label{fair:classic-semantics}
\end{figure}

Если текущее состояние является листом и не содержит вызовов, значит мы получили ответ. В этом случае мы применяем правило \rulen{Answer}.

Если текущее состояние является листом, но содержит хотя бы один вызов, мы применяем правило \rulen{ConjUnfold}. Оно недетерминировано выбирает произвольный конъюнкт $c$ и производит его развертку. Затем мы конструируем новое состояние из оставшихся вызовов $C_1$ и $C_2$ и результата развертки $T$ с помощью функции $push$.


Наконец, если текущее состояние является дизюнкцией, то мы производим вычисление в левом дизъюнкте $T_1$. В зависимости от результата мы приминяем или правило \rulen{Disj}, или правило \rulen{DisjStep}. Первое правило соответствует пустому состоянию и возвращает второй дизъюнкт $T_2$ в качестве результата. Второе правило соответствует непустому состоянию $\bar{T_1}$ и возвращает новое сотояние ($T_2 \lor \bar{T_1}$). Перестановка дизъюнктов --- необходимое действие, которое называется \emph{interleaving}~\cite{fair:interleaving}. Оно гарантирует полноту поиска.

Для того чтобы сделать начальное состояние $T_0$ из спецификации $(D_1 D_2\ldots D_k \diamond g$), нам необходимо в цели $g$ заменить все свободные синтаксические переменные на семантические, а также преобразовать её в состояние:
\[
{\inbr{\{\};\, n;\, \epsilon} \vdash g[x_0 \leftarrow \alpha_0, \ldots, x_{n-1} \leftarrow \alpha_{n-1}]} \leadsto T_0.
\]

\noindent Определения отношений $D_1, D_2, \ldots, D_k$ используются при развёртке отношений.

Данная семантика каждую спецификацию недетерминировано вычисляет с произвольным порядком разверток конъюнктов. При этом для конкретной спецификации при одном порядке развёрток вычисление может сходится, а при другом расходиться. 

Например, цель из главы~\ref{sec:exposition} (\lstinline|fail$\!^o$ _ /\ div$\!^o$ _|) сойдется при развёртке перого конъюнкта:

\[
\dfrac
{\dfrac
{\inbr{\{\}; \, 1; \epsilon} \vdash A \equiv B \leadsto \emptyset}
{(\{\}, 1) \vdash\! \mbox{\lstinline|fail|}\!^o\, \alpha_0  \Rightarrow \emptyset}}
{\inbr{\{\}; \, 1; \, \mbox{\lstinline|fail|}\!^o\, \alpha_0 \land \mbox{\lstinline|div|}\!^o\, \alpha_0} \xrightarrow{\circ} \emptyset}
\]

\noindent Действительно развёртка вызова \lstinline|fail$\!^o$| за один шаг приводит нас к пустому состоянию. В то же при развётрке только второго конъюнкта вычисление разойдётся:

\[
\dfrac
{\dfrac
{\inbr{\{\}; \, 1; \epsilon} \vdash \mbox{\lstinline|div|}\!^o\, \alpha_0 \leadsto \inbr{\{\}; \, 1; \mbox{\lstinline|div|}\!^o\, \alpha_0}}
{(\{\}, 1) \vdash\! \mbox{\lstinline|div|}\!^o\, \alpha_0  \Rightarrow \inbr{\{\}; \, 1; \mbox{\lstinline|div|}\!^o\, \alpha_0}}}
{\inbr{\{\}; \, 1; \, \mbox{\lstinline|fail|}\!^o\, \alpha_0 \land \mbox{\lstinline|div|}\!^o\, \alpha_0} \xrightarrow{\circ} \inbr{\{\}; \, 1; \, \mbox{\lstinline|fail|}\!^o\, \alpha_0 \land \mbox{\lstinline|div|}\!^o\, \alpha_0}}
\]

\noindent Состояние до развёртки вызова \lstinline|div$\!^o$| совпадает с состоянием после развёртки, поэтому, если разворачивать только вызов \lstinline|div$\!^o$|, вычисление расходится.

При этом нами было доказано, что данная семантика эквивалентна денатоционнй семантике \mk~\cite{fair:semantics}, поэтому любой порядок развёрток приводит к одинаковому набору ответов с точностью до порядка этих ответов.
\textcolor{red}{Понятно, что надо подробнее о доказательстве. Но чтобы хотя бы сформулировать теоремы о полноте и корректности надо описать, что такое represent function, след семантики, денотационный образ состояния и т.д.. Хочу обсудить, насколько подробно нужно.}

В отличие от классических left-biased реализаций \mk данная недетерминированная семантика сходится вне зависимости от порядка конъюнктов. Однако она недетерминирована, что сводит к нулю практическую ценность данной семантики. Поэтому в следующих главах мы обсудим две детерминированные семантики, которые сходятся тогда и только тогда, когда сходится недетерминированная.