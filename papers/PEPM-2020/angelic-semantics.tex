\section{Angelic Semantics}
\label{sec:angelic-semantics}

In this section we introduce an \emph{angelic} operational semantics of \mk. Instead of a fixed order of conjunct evaluation this semantics chooses a conjunct nondeterministically
thus enumerating all possible orders of their evaluation. Thus, if a goal (in particular, a conjunction) diverges in the angelic semantics then no order of evaluation exists which
would make it to converge.

The development of this (and the following) section essentially relies on the results reported in~\cite{fair:semantics}. In the paper, two semantics for \mk are presented. The first one is
denotational set-theoretic close to the least Herbrand model~\cite{Lloyd}; the second is operational semantics of relational search with interleaving in the form of labelled transition
system~\cite{LTS}, which corresponds to the informal description given in the previous section. Then the correctness and completeness of interleaving search w.r.t. the denotational semantics
is formally established and mechinized using \textsc{Coq} proof assistant~\cite{Coq}. It is also establishes a corollary that for correct and complete operational semantics some
transformations of goals are equivalent (w.r.t. the set of answers they provide). These transformations will play an important role is justifying the fairness of the semantics we present
in the next section. Due to space limitations, however, we do not present here these semantics and only sketch the proofs which use them essentially.
 
As a first step we define a set of \emph{semantic} variables

\[
\mathcal{A}=\{\alpha_0,\alpha_1,\dots\}
\]

A set of \emph{semantic terms} $\mathcal{T}_{\mathcal A}$ then comes in naturally. We stiputate that all semantic variables are linearly ordered making it possible to take them one-by-one
in a deterministic manner. We will also use conventional notations of $\mathcal{FV}\,(\bullet)$ for the sets of free variables in terms and goals and $\bullet\,[x\gets t]$ for substitutions
of \emph{semantics} term $t$ for \emph{syntactic} variable $x$ in terms and goals. As the only binder in goals~--- the ``\lstinline|fresh|'' construct~--- can only bind \emph{syntactic}
variables no capturing can occur during substitutions. We omit the formal definitions due to their triviality.

Next, we define the following set of \emph{states} $\mathfrak{S}$:

\[
\begin{array}{rccll}
  \mathfrak{S} & = &     & \times                         & \mbox{final state}\\
               &   &\mid & \inbr{\theta,\,i,\,r^*}        & \mbox{leaf state}\\
               &   &\mid & \mathfrak{S}\oplus\mathfrak{S} & \mbox{disjunction}\\
  r            & = &     & R^k\,(t_1,\dots,t_k)            & \mbox{relation application}
\end{array}
\]

A non-final state is a tree of disjunctions with leaves of the form $\inbr{\theta,\,i,\,r^*}$, where $\theta$ is a substitution from semantic variables into semantic terms,
$i$~--- the index of the first non-allocated semantic variable, and $r^*$~--- a possibly empty list of relation applications $R^k\,(t_1,\dots,t_k)$, where $R^k$~--- relation name,
$t_i$~--- semantic terms. Informally, a state represents some point during goal evaluation when the results of (non-failed) unifications are collected in substitutions and the residual
goal is represented in DNF. If a list of relation applications in the leaf of the state is empty, then the substitution represents an answer. A final state corresponds to the end of evaluation.

We introduce two auxilliary functions to work with states. The first one, \primi{union}, joins two states into the one:

\[
\begin{array}{rcl}
  \primi{union}\,(\times,\, S) & = & S \\
  \primi{union}\,(S,\, \times) & = & S \\
  \primi{union}\,(S_1,\, S_2) & = & S_1\oplus S_2
\end{array}
\]

The next one, \primi{push}, is used to reconstruct a state after unfolding a single relation application:

\[
\begin{array}{rcl}
  \primi{push}\,(\_,\,\times) & = & \times\\
  \primi{push}\,(c,\,S_1\oplus S_2) & = & \primi{push}\,(c,\,S_1)\oplus\primi{push}\,(c,\,S_2)\\
  \primi{push}\,(\rho\Box\pi,\,\inbr{\theta,\,i,\,\sigma}) & = & \inbr{\theta,\,i,\,\rho\sigma\pi}
\end{array}
\]

The first argument of \primi{push} is a list of relation applications which contains a \emph{hole} ``$\Box$''. The hole indicates the place in which
an unfolded relation application was located. The second argument is a state which represents the result of unfolding. Thus, \primi{push} propagates the
context of the unfolding through its resulting local state.

Now we define the semantics for one-step unfolding of relation application. Informally, we take an application of a relation symbol to some semantic term, substitute these
terms for corresponding arguments in the relation definition body, perform all unifications and transform the rest of the body into DNF. As a result we acquire some state. Note, we
do not perform unfoldings of relation applications within the body. We describe one-step unfolding in terms of a big-step relation ``$\Rightarrow$'' with the following
single rule:

\[
\begin{array}{cr}
  \dfrac{R = \lambda \bar{x}. b \qquad \inbr{\theta,\, i,\, \epsilon} \vdash b\,[\bar{x} \leftarrow \bar{t}] \leadsto S}
      {\inbr{\theta,\,i} \vdash R\,(\bar{t}) \Rightarrow S}
      &     \ruleno{Unfold}
\end{array}
\]

We conventionally denote here $\bar{\bullet}$ vectors of terms or variables. In the conclusion we use a pair of a substitution and a number of first unallocated semantic variable as
environment; in the premise, however, we need to refer to a yet another, this time small-step, relation ``$\leadsto$'', which uses states as environment. This relation describes the
local computations within the body of unfolded application.  The definition of this relation is shown in the Fig.~\ref{fair:unfolding-semantics}.

\begin{figure}[t]
\[\begin{array}{cr}
{\times \vdash g \leadsto \times}
&     \ruleno{End} \\[3mm]
\dfrac{\not\exists \, mgu\,(t_1,\, t_2,\, \theta)}
      {\inbr{\theta,\, i,\, c} \vdash t_1 \equiv t_2 \leadsto \times}
&     \ruleno{UnifyFail}  \\[6mm]
\dfrac{\theta^\prime = mgu\,(t_1,\, t_2,\, \theta)}
      {\inbr{\theta,\, i,\, c} \vdash t_1 \equiv t_2 \leadsto \inbr{\theta^\prime,\, i,\, c}}
&     \ruleno{UnifySucc}  \\[6mm]
      {\inbr{\theta,\, i,\, c} \vdash R\,(\bar{t}) \leadsto \inbr{\theta,\, i,\,cR\,(\bar{t})}}
&     \ruleno{App} \\[3mm]
\dfrac{\inbr{\theta,\, i+1,\, c} \vdash g\,[x \leftarrow \alpha_i] \leadsto S}
      {\inbr{\theta,\, i,\, c} \vdash \mbox{\lstinline|fresh|} (x)\, g \leadsto S}
&     \ruleno{Fresh}  \\[6mm]
\dfrac{\inbr{\theta,\, i,\, c} \vdash g_1 \leadsto S_1 \qquad \inbr{\theta,\, i,\, c} \vdash g_2 \leadsto S_1}
      {\inbr{\theta,\, i,\, c} \vdash g_1 \lor g_2 \leadsto \primi{union}\,(S_1,\, S_2)}
&     \ruleno{DisjGoal}  \\[6mm]
\dfrac{S_1 \vdash g \leadsto S_3 \qquad S_2 \vdash g \leadsto S_4}
      {S_1 \oplus S_2 \vdash g \leadsto \primi{union}\,(S_3,\, S_4)}
&     \ruleno{DisjState}  \\[6mm]
\dfrac{\inbr{\theta,\, i,\, c} \vdash g_1 \leadsto S \qquad S \vdash g_2 \leadsto S^\prime}
      {\inbr{\theta,\, i,\, c} \vdash g_1 \land g_2 \leadsto S^\prime}
&     \ruleno{Conj}
\end{array}\]
\caption{Small-step semantics of local compuatations}
\label{fair:unfolding-semantics}
\end{figure}

The rule \rulen{End} propagates a final state through the rest of the computations. The rules \rulen{UnifyFail} and \rulen{UnifySucc} encode unification steps: if there exists the most general
unifier (MGU) for given terms in given substitution $\theta$, then we update the substitution according to the MGU; otherwise we produce a final state. The rule \rulen{App} preserves a relation
application, adding it to the list of applications in the current leaf state. The rule \rulen{Fresh} corresponds to a fresh semantic variable allocations. We take the first non-allocated semantic
variable and substitute it for the fresh-bound syntactic one; we also increment the number of non-allocated variables. The rules \rulen{DisjGoal} and \rulen{DisjState} describe the evaluation
of disjunctions. The first one evaluates both disjuncts and joins the resulting states by mean of primitive \primi{union}. The second handles the case when current environment state is a disjunction
itself. As in the first case, we perform independent evaluations and join the results. Finally, the rule \rulen{Conj} describes conjunction evaluation. Here we first evaluate the left subgoal,
acquiring a state $S$, and then evaluate the right one in the context $S$, obtaining the final result $S^\prime$. Note, as we do not perform any unfoldings, the process always converges with
some state.

Having one-step unfolding at our command, we can define the angelic semantics itself (Fig.~\ref{fair:angelic-semantics}). The semantics is defined in terms of a labeled transition
system over the set of states. The set of labels is defined as

\[
\mathcal{L} = \circ \mid \theta.
\]

where ``$\circ$'' designates the absence of an answer, обозначает отсутствие ответа, в противном случае ответом является подстановка.

Теперь у нас есть всё необходимое, чтобы определить недетерминированную семанику реляционного языка (Fig.~\ref{fair:classic-semantics}). Данная семантика малого шага последовательно преобразовывает состояние и периодически производит ответы, которыми являются итоговые подстановки, которые помещаются над символом перехода ``$\xrightarrow{}$''. В противном случае над символом перехода будет помещена метка ``$\circ$''.

\begin{figure}[h!]
\[\begin{array}{cr}
     {\inbr{\theta;\, i;\, \epsilon} \xrightarrow{\theta} \emptyset}  
&     \ruleno{Answer} \\[2mm]
\dfrac{(\theta, i) \vdash c \Rightarrow T}
      {\inbr{\theta;\, i;\, C_1 \land c \land C_2} \xrightarrow{\circ} push(C_1 \land \Box \land C_2, T)}
&     \ruleno{ConjUnfold} \\[4mm]
\dfrac{T_1 \xrightarrow{\alpha} \emptyset}
      {T_1 \lor T_2 \xrightarrow{\alpha} T_2}
&     \ruleno{Disj} \\[4mm]
\dfrac{T_1 \xrightarrow{\alpha} \bar{T_1} \qquad \bar{T_1} \not= \emptyset}
      {T_1 \lor T_2 \xrightarrow{\alpha} T_2 \lor\bar{T_1}}
&     \ruleno{DisjStep}
\end{array}\]
\caption{Angelic semantics of \mk}
\label{fair:angelic-semantics}
\end{figure}

Если текущее состояние является листом и не содержит вызовов, значит мы получили ответ. В этом случае мы применяем правило \rulen{Answer}.

Если текущее состояние является листом, но содержит хотя бы один вызов, мы применяем правило \rulen{ConjUnfold}. Оно недетерминировано выбирает произвольный конъюнкт $c$ и производит его развертку. Затем мы конструируем новое состояние из оставшихся вызовов $C_1$ и $C_2$ и результата развертки $T$ с помощью функции $push$.


Наконец, если текущее состояние является дизюнкцией, то мы производим вычисление в левом дизъюнкте $T_1$. В зависимости от результата мы приминяем или правило \rulen{Disj}, или правило \rulen{DisjStep}. Первое правило соответствует пустому состоянию и возвращает второй дизъюнкт $T_2$ в качестве результата. Второе правило соответствует непустому состоянию $\bar{T_1}$ и возвращает новое сотояние ($T_2 \lor \bar{T_1}$). Перестановка дизъюнктов --- необходимое действие, которое называется \emph{interleaving}~\cite{fair:interleaving}. Оно гарантирует полноту поиска.

Для того чтобы сделать начальное состояние $T_0$ из спецификации $(D_1 D_2\ldots D_k \diamond g$), нам необходимо в цели $g$ заменить все свободные синтаксические переменные на семантические, а также преобразовать её в состояние:
\[
{\inbr{\{\};\, n;\, \epsilon} \vdash g[x_0 \leftarrow \alpha_0, \ldots, x_{n-1} \leftarrow \alpha_{n-1}]} \leadsto T_0.
\]

\noindent Определения отношений $D_1, D_2, \ldots, D_k$ используются при развёртке отношений.

Данная семантика каждую спецификацию недетерминировано вычисляет с произвольным порядком разверток конъюнктов. При этом для конкретной спецификации при одном порядке развёрток вычисление может сходится, а при другом расходиться. 

Например, цель из главы~\ref{sec:exposition} (\lstinline|fail$\!^o$ _ /\ div$\!^o$ _|) сойдется при развёртке перого конъюнкта:

\[
\dfrac
{\dfrac
{\inbr{\{\}; \, 1; \epsilon} \vdash A \equiv B \leadsto \emptyset}
{(\{\}, 1) \vdash\! \mbox{\lstinline|fail|}\!^o\, \alpha_0  \Rightarrow \emptyset}}
{\inbr{\{\}; \, 1; \, \mbox{\lstinline|fail|}\!^o\, \alpha_0 \land \mbox{\lstinline|div|}\!^o\, \alpha_0} \xrightarrow{\circ} \emptyset}
\]

\noindent Действительно развёртка вызова \lstinline|fail$\!^o$| за один шаг приводит нас к пустому состоянию. В то же при развётрке только второго конъюнкта вычисление разойдётся:

\[
\dfrac
{\dfrac
{\inbr{\{\}; \, 1; \epsilon} \vdash \mbox{\lstinline|div|}\!^o\, \alpha_0 \leadsto \inbr{\{\}; \, 1; \mbox{\lstinline|div|}\!^o\, \alpha_0}}
{(\{\}, 1) \vdash\! \mbox{\lstinline|div|}\!^o\, \alpha_0  \Rightarrow \inbr{\{\}; \, 1; \mbox{\lstinline|div|}\!^o\, \alpha_0}}}
{\inbr{\{\}; \, 1; \, \mbox{\lstinline|fail|}\!^o\, \alpha_0 \land \mbox{\lstinline|div|}\!^o\, \alpha_0} \xrightarrow{\circ} \inbr{\{\}; \, 1; \, \mbox{\lstinline|fail|}\!^o\, \alpha_0 \land \mbox{\lstinline|div|}\!^o\, \alpha_0}}
\]

\noindent Состояние до развёртки вызова \lstinline|div$\!^o$| совпадает с состоянием после развёртки, поэтому, если разворачивать только вызов \lstinline|div$\!^o$|, вычисление расходится.

При этом нами было доказано, что данная семантика эквивалентна денатоционнй семантике \mk~\cite{fair:semantics}, поэтому любой порядок развёрток приводит к одинаковому набору ответов с точностью до порядка этих ответов.
\textcolor{red}{Понятно, что надо подробнее о доказательстве. Но чтобы хотя бы сформулировать теоремы о полноте и корректности надо описать, что такое represent function, след семантики, денотационный образ состояния и т.д.. Хочу обсудить, насколько подробно нужно.}

В отличие от классических left-biased реализаций \mk данная недетерминированная семантика сходится вне зависимости от порядка конъюнктов. Однако она недетерминирована, что сводит к нулю практическую ценность данной семантики. Поэтому в следующих главах мы обсудим две детерминированные семантики, которые сходятся тогда и только тогда, когда сходится недетерминированная.
