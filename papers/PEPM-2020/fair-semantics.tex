\section{Fair Conjunction by Well-Quasi Ordering}
\label{sec:fair-semantics}

В этой секции мы рассмотрим детерминированную параметризованную семантику языка \mk, которая с помощью предиката-параметра динамически определяет
глубину раскркутки вызова. Также мы рассмотрим влияние нескольких предикатов на свойства семантики. Наконец, мы укажем достаточное условие на предикат,
при котором эта семантка становится справедливой.

Прежде всего нам необходимо переопределить множество состояний:

\[
\begin{array}{rcll}
\mathcal{H} & = & \epsilon \mid (\theta, r) : \mathcal{H} & \mbox{history of unfolded applications}\\
\mathfrak{S} & = & \inbr{\theta;\, i;\, (r, \mathcal{H})^*} & \mbox{leaf state with histories}\\
             & \mid &\mathfrak{S} \oplus \mathfrak{S} & \mbox{disjunction state} \\[1mm]
\end{array}
\]

\noindent Теперь в состоянии каждому вызову соответствует $h$~--- история развёрток, предшествующих появлению этого вызова. Данная история содержит исчерпывающую информацию, которая требуется для определения необходимости развертки вызова.  

Отметим, что синтаксис, вспомогательная функция {\bf union}, семантика развертки остается без изменений. Функция {\bf push} также сохраняет свое поведение, однако теперь она принимает набор  с дыркой пар вызовов и историй и обновленное состояние. Дополнительно нам понадобится функция {\bf set}, которая принимает состояние без историй $S$ и историю $h$. Эта история присоединяется к каждому вызову в состоянии:

\[
\begin{array}{rcl}
    \primi{set}(\times, \_) & = & \times \\
    \primi{set}(S_1 \oplus S_2, h) & = & \primi{set}(S_1, h) \oplus \primi{set}(S_2, h) \\
    \primi{set}(\inbr{\theta;\, i;\, r_1\ldots r_n}, h) & = & \inbr{\theta;\, i;\, (r_1, h) \ldots (r_n, h)} 
\end{array}
\]

Предикат $pred$, которым мы параметризуем семантику, принимает подстановку, вызов и историю этого вызова. Он возвращает \lstinline|true|, если вызов необходимо разворачивать дальше. И возвращает \lstinline|false|, если необходимо перейти к следующему конъюнкту.

\begin{figure}[h!]
\[\begin{array}{cr}
      {\inbr{\theta;\, i;\, \epsilon} \xrightarrow{\theta}_p \times}  
&     \ruleno{Answer} \\[4mm]
      \dfrac
      {\begin{array}{c}
           \bigvee_{j=1}^n h_j \not= \epsilon \\
           \bigwedge_{j=1}^n pred(\theta, r_j, h_j) = \mbox{\lstinline{false}}
      \end{array}}
      {\begin{array}{l}
      \inbr{\theta;\, i;\, (r_1,h_1) \ldots (r_n,h_n)} \xrightarrow{\circ}_p \\
      \phantom{XXXX} \inbr{\theta;\, i;\, (r_1,\epsilon) \ldots 
      (r_n, \epsilon)}
      \end{array}}
      &  \ruleno{ConjClear} \\[10mm]
      
      \dfrac
      {
        \begin{array}{c}
          \bigwedge_{j=1}^{k-1} pred(\theta, r_j, h_j) = \mbox{\lstinline{false}} \\
          pred(\theta, r_k, h_k) = \mbox{\lstinline{true}} \\
          (\theta, i) \vdash r_k \Rightarrow S \\
          \primi{set}(S, \, (\theta, r_k) : h_k) = S'
        \end{array}
      }
      {
        \begin{array}{l}
          \inbr{\theta;\, i;\, (r_1,h_1) \ldots (r_{k-1},h_{k-1}) (r_k, h_k) \pi} \xrightarrow{\circ}_p \\
          \phantom{XXXX}\primi{push}( (r_1,h_1) \ldots (r_{k-1},h_{k-1})\Box \pi, S')
         \end{array}
        }
&     \ruleno{ConjUnfold} \\[10mm]
\dfrac{S_1 \xrightarrow{\alpha}_p \times}
      {S_1 \oplus S_2 \xrightarrow{\alpha}_p S_2}
&     \ruleno{Disj} \\[6mm]
\dfrac{S_1 \xrightarrow{\alpha}_p S'_1 \qquad S'_1 \not= \times}
      {S_1 \oplus S_2 \xrightarrow{\alpha}_p S_2 \oplus S'_1}
&     \ruleno{DisjStep}
\end{array}\]
\caption{Semantics of \mk with predicate}
\label{fair:pred-fair-semantics}
\end{figure}

Семантика, параметризованная предикатом раскрутки представлена на изображении~\ref{fair:pred-fair-semantics}. Так как мы обновляем только поведение конъюнкции, то правила \rulen{Answer}, \rulen{Disj} и \rulen{DisjStep} остаются без изменений. За обработку конъюнкций отвечают правила \rulen{ConjClear} и \rulen{ConjUnfold}. Если предикат истинен хотя бы для одного вызова, то мы применяем правило\rulen{ConjUnfold} и разворачиваем самый левый такой вызов, пополняя историю новых вызовов с помощью функции {\bf set}. Если предикат ложен на всех вызовах, и хотя бы одна история не пуста, то мы применяем правило \rulen{ConjClear}, которое стирает историю всех вызовов, заменяя на $\epsilon$.

Отметим, что не всякий предикат сохраняет soundness. Например, при предикате, который всегда возвращает \lstinline{false} к состоянию $\inbr{\{\};\, i; \, (r, \epsilon)}$ ни одно из правил не может быть применено. Для гарантии soundness нам необходмо портебовать, чтобы предикат был истинным при пустой истории $\epsilon$.

\begin{lemma}
\label{lemma:pred-property}
 If for any substitution $\theta$ and for any relation application $r$,  $pred(\theta, r, \epsilon) =$ \lstinline{true}, then for any state $S \not= \times$ exists state $S'$, 
 $$S \xrightarrow{\alpha}_p S'$$.
\end{lemma}

Все дальнейшие предикаты, которые мы будем рассматривать удовлетворяют условию леммы~\ref{lemma:pred-property} тривиальным образом.

Семантика, параметризрованная предикатом достаточна гибка в настройке. В зависимости от выбора предиката мы можем получить семантики с очень разными поведениями. Например, при константном предикате
\[
pred_{\mbox{\lstinline{true}}}(\theta, r, h) = \mbox{\lstinline{true}} 
\]
\noindent мы получим left-biased семантку, которая всегда вычисляет самый левый вызов. Таким же свойством обладают классические реализации \mk.

Если предикат будет следить за размером истории
\[
pred_N(\theta, r, h) =  length(h) \leq N
\]

\noindent мы получим семантику, которая последовательно разворачивает вызовы слева направо на фиксированную глубину $N > 0$. Данная техника схожа с $\bot$-avoiding streams~\cite{fair:WillThesis}~--- основаной на ferns~\cite{fair:ferns} структуре данных, разработанной для избегания расхождения. Если в случае с $\bot$-avoiding stream мы получаем полноту вычисления дизъюнктов, то наше ограничение количества шагов в конъюнкте позволяет получить полноту развёртки конъюнктов.

Важным для нас классом предикатов являются predicates by well-quasi-ordering. Пусть $(\leq)$~--- well-quasi-ordering над множеством кортежей из подстановок $\sigma$ и вызовов $c$. Тогда
\[
pred_\leq(\theta, r, h) = \left\{
\begin{array}{rl}
\mbox{\lstinline{true}}  & \mbox{if } \exists (\theta_0, r_0) \in h. \, (\theta, r) \leq (\theta_0, r_0) \\
\mbox{\lstinline{false}} & \mbox{otherwise}
\end{array}
\right.
\]

\noindent Такой предикат гарантирует, что всякий вызов в состоянии будет развёрнут за конечное число шагов семантики. 

\begin{lemma}
Let $pred$ is a predicate by well-quasi-ordering, $S$ is a state, $r \in S$ is a relation application. Then exists state $S'$,
$$S[r \leftarrow \boxed{r}] \rightarrow_p^* S' \mbox{and}\;\, \boxed{r} \not\in S'.$$
\end{lemma}

\noindent Здесь $\boxed{r}$~--- boxed вызов, обрабатываемый семантикой также, как и исходый вызов $r$, $S[r \leftarrow \boxed{r}]$~--- подстановка $\boxed{r}$ вместо вызов $r$

Более того, predicate by well-quasi-ordering гарантирует максимальную сходимость в сравнении с ангеличиеской семантикой.

\begin{theorem}
Let $pred$ is a predicate by well-quasi-ordering, $S$ is a state.
If $S \rightarrow^* \times$ in angelic semantics then $S \rightarrow^*_p \times$.
\end{theorem}

Из этой теоремы следует, что семантика справедлива, то есть не зависит от порядка конъюнктов, ведь сходимость ангельской семантики не зависит от порядка конъюнктов.

\begin{corollary}
Let $r_1, r_2$ are relation applications, $\theta$ is substitution and $i \in \mathbb{N}$. If
$$\inbr{\theta;\, i;\, (r_1,\epsilon) (r_2,\epsilon)} \rightarrow^*_p \times$$ 
then 
$$\inbr{\theta;\, i;\,(r_2,\epsilon) (r_1,\epsilon)} \rightarrow^*_p \times.$$
\end{corollary}

\begin{comment}

% В качестве предиката нам необходим критерий, отличающий вызов, который выгодно раскрутить сейчас от вызова, который стоит отложить. Мы предлагаем критерий, который корректно работает на отношениях со структурной рекурсией. У таких отношений есть хотя бы один аргумент, который структурно убывает с каждым шагом рекурсии. Это свойство позволит нам контролировать грубину раскрутки. Предлагаемый критерий состоит в следующем
As for the predicate, we need a criterion that can tell a call that is profitable to unfold now apart from a call which is worth deferring. We propose a criterion that works correctly
for structurally recursive relations. Such relations have at least one argument which structurally decreases with each step of the recursion. This property allows us to control the depth
of unfolding. We propose to use the following predicate:

\[
pred(\sigma, F^k(t_1, \ldots, t_k)) = \left\{
\begin{array}{cl}
      & \mbox{if } F^k \mbox{ is structural recursion relation, } \\
\top, & i \mbox { is number of structural recursion argument, } \\
      & t_i \mbox { is not fresh variable in } \sigma \\
\bot, & \mbox{otherwise.}
\end{array}
\right.
\]

% Пока хотя бы один аргумент, по которому ведется структурная рекурсия не является свободной переменной, мы продолжаем разворачивать этот вызов. Если все такие аргументы свободны, то в текущей подстановке отношение разойдется, поэтому мы переходим к вычислению следующего вызова. Так как аргументы структурной рекурсии убывают, то за конечное число шагов вычисление либо завершится, либо все аргументы структурной рекурсии станут свободными переменными.

As long as at least one argument along which structural recursion is performed is not a free variable, we continue to unfold this call. If all such arguments are free, then the call
will diverge in the current substitution, so we proceed to evaluate the next call. Since structurally recursive arguments decrease, in a finite number of steps the evaluation will
either complete, or all arguments of structural recursion will become free variables.

% Например, отношение appendo является структурно рекурсивным по первому и третьему аргументу. Действительно, вложенный вызов appendo в качестве первого аргумента принимает xs, который является подтермом x. Также в качестве третьего аргумента appendo принимает xys, который является подтермом xy. Если хотя бы один из них~--- список фиксированной длины, то отношение сойдется. В противном случае, оба имеют вид: $x = t_1 : \ldots t_n : \alpha$ и $xy = \bar{t}_1 : \ldots \bar{t}_m : \alpha$. Следовательно через max(n, m) шагов оба аргумента станут свободными перееменными. 
For example, the relation \lstinline{append$^o$} (Fig.~\ref{fair:lst-appendo} from section~\ref{sec:minikanren}) is structurally recursive on its first and third arguments. Indeed, the nested call \lstinline{append$^o$}
takes \lstinline{xs} as its first argument, which is a subterm of \lstinline{x}. Also, \lstinline{append$^o$} takes \lstinline{xys} as the third argument, which is a subterm of
\lstinline{xy}. If at least one of them is a fixed-length list, then the relation will converge. Otherwise, $\mbox{\lstinline{x}} \equiv t_1 : \ldots t_n : \alpha_1$
and $\mbox{\lstinline{xy}} \equiv \bar{t}_1 : \ldots \bar{t}_m : \alpha_2$. Therefore, in $max(n, m)$ steps, both arguments become free variables.

% На текущий момент мы работаем над доказательством независимости данной семантики от порядка конъюнктов в случае, когда все отношения являются отношениями со структурной рекурсией.
We are currently working on proving the independence of this semantics from the order of the conjuncts in the case when all relations are structurally recursive.
\end{comment}
