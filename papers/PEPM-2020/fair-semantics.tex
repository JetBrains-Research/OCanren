\begin{figure*}[t]
\[\begin{array}{cr}
      \dfrac
      {
      \bigvee_{j=1}^n h_j \not= \epsilon \qquad
      \bigwedge_{j=1}^n \neg\mathcal{P}\,(\theta,\,r_j,\,h_j)
      }
      {\begin{array}{l}
      \inbr{\theta,\, i,\, (r_1,\,h_1) \ldots (r_n,\,h_n)} \xrightarrow{\circ}_p \inbr{\theta,\, i,\, (r_1,\epsilon) \ldots (r_n,\, \epsilon)}
      \end{array}}
      &  \ruleno{ConjClear} \\[10mm]
      \dfrac
      {
       \bigwedge_{j=1}^{k-1} \neg\mathcal{P}\,(\theta,\, r_j,\, h_j) \qquad
       \mathcal{P}\,(\theta,\, r_k,\, h_k) \qquad
       \inbr{\theta,\, i} \vdash r_k \Rightarrow R 
      }
      {
        \begin{array}{l}
          \inbr{\theta,\, i,\, (r_1,\,h_1) \ldots (r_{k-1},\,h_{k-1}) (r_k,\, h_k) \pi} \xrightarrow{\circ}_p \primi{push}\,((r_1,\,h_1) \ldots (r_{k-1},\,h_{k-1})\Box \pi,\, \primi{set}\,(R, \, (\theta, r_k) : h_k))
         \end{array}
        }
&     \ruleno{ConjUnfold$^*$} 
\end{array}\]
\caption{Generic semantics}
\label{fair:pred-fair-semantics}
\end{figure*}

\section{Fair Conjunction by Well Quasi-Ordering}
\label{sec:fair-semantics}

In this section we present a deterministic fair semantics for \mk. From a purely theoretical standpoint there is nothing challenging in the task~--- 
as interleaving of disjunction evaluation provides the completeness of the search the interleaving of conjunction evaluation would provide its fairness. In other words it
would suffice to change the ``focus'' of the evaluation from one conjunct to another after the first step (or any finite number of steps) to hit the goal. Alas,
this drastic approach leads to so unfortunate performance degradation that it makes the whole idea impractical. The problem is to guess the good time to suspend the
evaluation; if a conjunct is ``about'' to provide an answer its evaluation should be continued. Thus, we are looking for a certain runtime test which would say
us to ``give up'' at the right time taking into account the intrinsic properties of the program being evaluated.

It is interesting that exactly the same problem arises in the domain of \emph{metacomputations}. In supercompilation~\cite{Turchin}
\emph{driving} (symbolic execution) of a program can lead to a potentially infinite unfolding. To deal with this difficulty a certain technique~---
\emph{generalization}~\cite{Sorensen95analgorithm}~--- is used to make the process converge. However, both premature and deferred generalizations are undesirable.
In the practice of supercompilation a certain technique, based on the notion of \emph{well quasi-ordering}, has confirmed its applicability.

\begin{definition}
  A well quasi-ordering on a set $\Sigma$ is a preorder ``$\trianglelefteq$'' such that in an arbitrary infinite sequence $x_1,x_2,\dots$ of elements
  of $\Sigma$ there are such elements $x_i$ and $x_j$ that $i<j$ and $x_i\trianglelefteq x_j$.
\end{definition}

From a practical standpoint well quasi-ordering can help to detect the divergence (infinity) of a certain sequence of computational steps. In our approach
to fairness we use this idea. First, we define a very generic deterministic semantics equipped with a certain predicate which determines the discipline of
switching. Then we prove that under a certain requirements on the predicate the semantics becomes fair. Finally, we present a concrete predicate based on
a concrete well quasi-ordering and show that it fulfills that requirements.

First, we introduce the set of \emph{enriched} states $\mathfrak{R}$:

\[
\begin{array}{rccll}
  \mathcal{H}    & = &      & \inbr{\theta,\,r}^* & \mbox{history of unfoldings}\\
  \mathfrak{R}   & = &      & \times & \mbox{final state}\\
                 &   & \mid & \mathfrak{R}^o & \mbox{non-final state}\\
  \mathfrak{R}^0 & = &      & \inbr{\theta,\, i,\, \inbr{r,\, \mathcal{H}}^*} & \mbox{leaf state with histories}\\
                 &   & \mid & \mathfrak{R}^0 \oplus \mathfrak{R}^0 & \mbox{disjunction state}
\end{array}
\]

We added here the notion of a \emph{history}. A history is a possibly empty list of pairs of substitutions and relation applications. In a leaf state now each
relation application is equipped with a history of unfoldings which led to this application.

The supplementary functions \primi{union} and \primi{push} keep their definitions for enriched states (the presence of histories does not change their behavior).
In addition we need a new function~--- \primi{set}~--- which takes a regular state and a history and produces an enriched state by attaching the
history to each relation application in that state:

\[
\begin{array}{rcl}
    \primi{set}\,(\times, \_) & = & \times \\
    \primi{set}\,(S_1 \oplus S_2, h) & = & \primi{set}\,(S_1, h) \oplus \primi{set}\,(S_2, h) \\
    \primi{set}\,(\inbr{\theta,\, i,\, r_1\ldots r_n}, h) & = & \inbr{\theta,\, i,\, (r_1, h) \ldots (r_n, h)} 
\end{array}
\]

Our semantics is parameterized by a predicate $\mathcal{P}\,(\theta,\,r,\,h)$ where $\theta$ is a substitution, $r$~--- a relational application and $h$~--- a history. Informally,
$\mathcal{P}\,(\theta,\,r,\,h)$ determines if it is desirable to unfold $r$. The semantics itself completely reuses the one-step unfolding relation ``$\Rightarrow$'' and the
rules \rulen{Answer}, \rulen{Disj}, and \rulen{DisjStep} from the angelic one. One-step unfolding returns a regular, non-enriched state, while the rules deal with enriched
states (but graphically completely preserve their shape). The single rule \rulen{ConjUnfold}, however, is replaced with two other rules: \rulen{ConjClear} and \rulen{ConjUnfold$^*$}
(see Fig.~\ref{fair:pred-fair-semantics}, the transition relation is denoted by ``$\rightarrow_p$''). If $\mathcal{P}$ is true for atleast one relation application, we apply the
rule \rulen{ConjUnfold} and unfold the leftmost such application, setting the history of resulting applications using the function \primi{set}. If the predicate is false on all
relation applications, and there is atleast one non-empty history, then we apply the rule \rulen{ConjClear}, which removes the histories for each applications, replacing
them with $\epsilon$. 

The parameterization by the predicate delivers us a whole family of semantics, and not all members of this family are nice. For example,
if the predicate always stays false, then no steps can be performed from the state $\inbr{\Lambda,\, i, \, (r,\, \epsilon)}$, which compromises the completeness.
The following lemma delivers the necessary condition for completeness.

\begin{lemma}
\label{lemma:pred-property}
If

\[
\forall\;\theta,\;r\; :\;\mathcal{P}\,(\theta,\, r,\, \epsilon)
\]

then for any non-final state $R$ there is exists a state $R^\prime$, such that

\[
R \xrightarrow{\alpha}_p R^\prime
\]
\end{lemma}

All predicates which we consider further will trivially satisfy the conditions in Lemma~\ref{lemma:pred-property}.

By choosing the predicate we can come up with various existing semantics. For example, by setting it always true we get the regular left-biased one.

If the predicate limits the length of the history

\[
\mathcal{P}_N\,(\theta,\, r,\, h) = length\,(h) \leq N
\]

we get a semantics which consequtively unfolds relation applications from left to right up to a certain depth $N>0$. This technique resembles \emph{bottom-avoiding
streams}~\cite{fair:WillThesis}~--- a stream implementation based on utilization of a specific data structure, called ``ferns''~\cite{fair:ferns}, which is designed
to defer diverging computations.

In the context of our work an important class of predicates is \emph{well quasi-ordering predicates}. Let ``$\trianglelefteq$'' be a well quasi-ordering on the set of
pairs of substitutions and relational applications. Then we define

\[
\mathcal{P}_\trianglelefteq\,(\theta,\,r,\,h) = \forall\inbr{\theta_0,\,r_0}\in h\;:\; \inbr{\theta_0,\,r_0}\trianglelefteq \inbr{\theta,\,r}
\]

This sort of predicates guarantees, that each relation application in a state will be eventually unfolded after a finite number of steps. This property
forms a basis for the following central theorem:

\begin{theorem}
  Let $\mathcal{P}_\trianglelefteq$ be a well quasi-ordering predicate. Then ``$\rightarrow_{\mathcal{P}_\trianglelefteq}$'' is a fair semantics.
\end{theorem}
