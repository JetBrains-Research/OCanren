\documentclass[final,20pt]{beamer}

\usepackage[orientation=portrait,size=a0,scale=1.4]{beamerposter}
\usepackage{wrapfig}
\usepackage{listings}
\usepackage{verbatimbox}
\usepackage{filecontents}
\usepackage{hhline}
\usepackage{tikz}
\usepackage{comment}
\usetikzlibrary{backgrounds,tikzmark}

%% \usepackage[backend=bibtex,style=numeric,maxnames=2,firstinits=true]{biblatex}

\usetheme{confposter} % Use the confposter theme supplied with this template

%% \setbeamercolor{titlelike}         {bg=jblue,fg=white}
\setbeamercolor{block title example}{fg=white,bg=dgreen!70}
\setbeamercolor{block body example}{fg=black,bg=dgreen!10}
\setbeamercolor{block title}{fg=jblue,bg=white} % Colors of the block titles
\setbeamercolor{block body}{fg=black,bg=white} % Colors of the body of blocks
\setbeamercolor{block alerted title}{fg=white,bg=dblue!70} % Colors of the highlighted block titles
\setbeamercolor{block alerted body}{fg=black,bg=dblue!10} % Colors of the body of highlighted blocks
%\setbeamercolor{block example title}{fg=black,bg=dblue!70} % Colors of the example block titles
%\setbeamercolor{block example body}{fg=black,bg=dblue!10} % Colors of the body of example blocks
% Many more colors are available for use in beamerthemeconfposter.sty

% Define the column widths and overall poster size
\input{sizeDefs}
%% \input{sizeDefsVert}            

\usepackage{graphicx}
\usepackage{booktabs}
\usepackage{wasysym}

%% \bibliography{../references,../proceedings}

%% \input{../defs}
%% \input{../abbrevmap}
%% \lstset{escapeinside=||,basicstyle=\large}
%% \input{posterDefs}

\lstdefinelanguage{ocanren}{
keywords={fresh, let, in, match, with, when, class, type,
object, method, of, rec, while, not, do, done, as, val, inherit,
new, module, sig, deriving, datatype, struct, if, then, else, open, private, virtual, include, success, failure},
sensitive=true,
commentstyle=\small\itshape\ttfamily,
keywordstyle=\ttfamily\underbar,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {/\\}{{$\wedge$}}2 {\\/}{{$\vee$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
language=ocanren
}

%% \lstset{escapeinside=||}        

%% \setbeamertemplate{itemize item}{\color{\dbluecolor}$\blacktriangleright$}
%% \setbeamertemplate{itemize subitem}{\color{\bluecolor}$\blacktriangleright$}

\newcommand*{\code}[1]{\texttt{#1}}
\newcommand{\ocanren}[1]{\mbox{\lstinline|#1|}}
\newcommand{\Xrightarrow}[1]{\xrightarrow{\phantom{x}#1\phantom{x}}}

\begin{filecontents*}{appendo.ml}
  let rec append$^o$ x y xy =
    (x === [] /\ y === xy) \/
    (fresh (h t ty) (
      (x === h :: t) /\
      (append$^o$ t y ty) /\
      (xy === h :: ty)
    ))
\end{filecontents*}

\begin{filecontents*}{appendorun.ml}
(fun q -> append$^o$ [1; 2] [3] q) $\leadsto$ {q=[1; 2; 3]}
(fun q r -> append$^o$ q r [1; 2; 3]) $\leadsto$ $\bot$
\end{filecontents*}

\begin{filecontents*}{sorto.ml}
  let rec sort$^o$ xs ys =
    (xs === [] /\ ys === []) \/
    (fresh (s xst yst) (
      (ys === s :: yst) /\
      (smallest$^o$ xs s xst) /\  (*1*)
      (sort$^o$ xst yst)           (*2*)
    ))
\end{filecontents*}

\begin{filecontents*}{permo.ml}
  let rec perm$^o$ xs ys =
    (fresh (ts) (
      (sort$^o$ xs ts) /\ (sort$^o$ ys ts)
    ))
\end{filecontents*}

\begin{filecontents*}{divo.ml}
  let rec div$^o$ n m q r =
    (r === n /\ [] === q /\ plus$^o$ r m n /\ lt$^o$ r m) \/
    ([1] === q /\ eql$^o$ n m /\ plus$^o$ r m n /\ lt$^o$ r m) \/
    ((ltl$^o$ m n) /\ (lt$^o$ r m) /\ (pos$^o$ q) /\
     (fresh (nh nl qh ql qlm qlmr rr rh) (
       (split$^o$ n r nl nh) /\
       (split$^o$ q r ql qh) /\
       ((([] === nh) /\ ([] === qh) /\ 
         (minus$^o$ nl r qlm) /\ (mult$^o$ ql m qlm)) \/
        ((pos$^o$ nh) /\ (mult$^o$ ql m qlm) /\
         (plus$^o$ qlm r qlmr) /\
         (minus$^o$ qlmr nl rr) /\
         (split$^o$ rr r [] rh) /\
         (div$^o$ nh m qh rh))
       )
     ))
    )
\end{filecontents*}

\begin{filecontents*}{divoeasy.ml}
  let rec div$^o$ n m q r =
    (fresh (mq) (
      (mult$^o$ m q mq) /\ (plus$^o$ mq r n) /\ (lt$^o$ r m)
    ))
\end{filecontents*}


%----------------------------------------------------------------------------------------
%	TITLE SECTION 
%----------------------------------------------------------------------------------------

\title[Refutationally safer relational search]{Refutationally safer relational search}

\author
{\textbf{Dmitri Rozplokhas}\inst{1} \quad Dmitri Boulytchev\inst{2}}

\institute{
  \inst{1}%
  Saint Petersburg Academic University, Russia \quad
  \inst{2}%
  Saint Petersburg State University, JetBrains, Russia
}

%% \vspace*{.5cm}
%% {\normalsize
%% GitHub: \textbf{anlun/OperationalSemanticsC11}
%% \quad 
%% E-mail: \textbf{a.podkopaev@2009.spbu.ru}
%% }
%% \vspace*{-1cm}

%----------------------------------------------------------------------------------------

\begin{document}

%% \addtobeamertemplate{block end}{}{\vspace*{1ex}} % White space under blocks
%% \addtobeamertemplate{block alerted end}{}{\vspace*{1ex}} % White space under highlighted (alert) blocks

\setlength{\belowcaptionskip}{2ex} % White space under figures
\setlength\belowdisplayshortskip{2ex} % White space under equations

\begin{frame}[t] % The whole poster is enclosed in one beamer frame

\begin{columns}[t]
  \begin{column}{\sepwid}\end{column} % Empty spacer column

  \begin{column}{\onecolwid} % The first column
  
    \begin{block}{Relational programming}
      \begin{itemize}
        \item Construction of functions as relations.
        \item Allows execution in various directions \\ (e.g. get arguments by result value).
        \item Elegant solutions to non-trivial problems.
      \end{itemize}
      
      \textbf{\textcolor{blue}{Sorting}} for \textbf{\textcolor{blue}{generation of permutations}} \\
      \textbf{\textcolor{blue}{Typechecker}} for \textbf{\textcolor{blue}{inhabitation problem}} \\
      \textbf{\textcolor{blue}{Interpreter}} for \textbf{\textcolor{blue}{generation of quines}}
    \end{block}

    \begin{block}{MiniKanren}
      MiniKanren is a family of relational EDSLs.

      Host languages include:
      \begin{itemize}
        \item Scheme (original implementation)
        \item Closure
        \item Haskell
        %% \item Go
        \item OCaml (implementation we use)
      \end{itemize}
      Specification constructors:
      \begin{itemize}
        \item unification ($\equiv$) of two terms
        \item conjunction ($\wedge$) and disjunction ($\vee$)
        \item fresh variable introduction
      \end{itemize}
      
      \begin{exampleblock}{Example}
        Relational specification of list concatenation.
        \lstinputlisting{appendo.ml}
      \end{exampleblock}
    \end{block}
    
    \begin{block}{Problem}
      Interleaving search is guaranteed to find all answers. \\
      But it can diverge when no answers left.
      \lstinputlisting{appendorun.ml}
      \textbf{Reason:} non-commutativity of conjunction.
      \begin{figure}
        \large{Information passing}\\
        \begin{tikzpicture}
          \node[text width=6cm] at (0,0) {\huge $g_1 \wedge g_2$};
          \draw [->, line width=9, blue] (-7,0) -- (-3.5,0);
          \draw [->, line width=9, blue] (3.5,0) -- (7,0); 
          \draw [->, line width=9, blue] (-2,1) .. controls (-1,3) and (1,3) .. (2,1);
          \draw [->, line width=9, blue] (2,-1) .. controls (1,-3) and (-1,-3) .. (-2,-1);
          \draw [line width=9, red] (-0.75,-3.25) -- (0.75,-1.75); 
          \draw [line width=9, red] (-0.75,-1.75) -- (0.75,-3.25);
        \end{tikzpicture}
      \end{figure}
      Search in $g_1$ diverges $\Rightarrow$ search in $g_1 \wedge g_2$ diverges
      \bigskip
      \bigskip
      
      Specification is \textbf{Refutationally Complete}, if search by it always terminates when no answers left.
      \bigskip
      
      Shift of recursive call to the end makes {\ttfamily append$^o$} RC.
      It doesn't work in more complex cases.
    \end{block}

    \begin{alertblock}{Goal}
        Make it easier to write refutationally complete specifications.
    \end{alertblock}
    
    \begin{block}{Possible solutions}
      \begin{enumerate}
        \item Advanced technics of writing specifications, \\ such as bounding the sizes of terms
        \item Simulation of commutative conjunction
        \item Reordering of conjuncts during execution
        \item[\textcolor{red}{$\uparrow$}] \textcolor{red}{ \textbf{our approach} }
      \end{enumerate}
    \end{block}
  
  \end{column}

  \begin{column}{\sepwid}\end{column} % Empty spacer column

  \begin{column}{\onecolwid} % The second column
    
    \begin{block}{Conjuncts reordering approach}
      \textbf{Idea:} 
      \begin{enumerate}
        \item testing current search proccess for divergence
        \item try different order if it was detected
      \end{enumerate}
      This search extension is:
      \begin{itemize}
        \item online
        \item non-intrusive
        \item conservative
      \end{itemize}
    \end{block}
    
    \begin{block}{Examples}
      \begin{exampleblock}{Example}
        In relational sorting
	    \lstinputlisting{sorto.ml}
        for termination we need
        \begin{itemize}
        \item order $1 \to 2$ for direct execution
        \item order $2 \to 1$ for reverse execution
        \end{itemize}
        \bigskip
        Permutation relation based on it
        \lstinputlisting{permo.ml}
        requires execution in both directions.
        \bigskip
        
        Original search diverges with any order
        
        + search is too inefficient if length $> 3$.
	 \end{exampleblock}
     Extended search reconstructs (experimentally) \\ the way of information propagation for each call.

     Multidirectional calls (like in {\ttfamily perm$^o$}) converge.
      \bigskip
      \bigskip

     Extention allows to write RC specifications naively.
      \begin{exampleblock}{Example}
        For division with remainder in binary arithmetics:
        \[ n = m \cdot q + r, \quad r < m \]
        instead of this sophisticated solution
        \lstinputlisting{divo.ml}
        we can just write down definition
        \lstinputlisting{divoeasy.ml}
        and it will be RC under extended search.
      \end{exampleblock}
    \end{block}

  \end{column}

  \begin{column}{\sepwid}\end{column} % Empty spacer column

  \begin{column}{\onecolwid} % The third column
  
    \begin{block}{Non-termination test}
      \textbf{Observation}: in recursive call arguments are \\ \textit{more general} $\Rightarrow$ execution won't terminate
      \bigskip
      \bigskip
      
      \begin{center} Big-step semantics for OCanren \end{center}
	  \begin{center} $\Gamma, \iota \vdash (\sigma, \delta) \Xrightarrow{g} S$ \end{center}
      \begin{itemize}
        \item $\Gamma$ - function definitions
        \item $\iota$ - interpretation of syntactic variables
        \item $\sigma$ - current substitution
        \item $\delta$ - known logic variables
        \item $g$ - specification
        \item $S$ - result multiset of states
      \end{itemize}
      
$$
\def\arraystretch{3.3}
\begin{array}{c}
       %\Gamma,\,\iota \vdash (\sigma,\,\delta) \Xrightarrow{\ocanren{$t_1\;$ === $\;t_2$}} 
       %  \left\{
       %     \def\arraystretch{1}
       %     \begin{array}{c}
       %        \{(\sigma\ \mbox{\bf{mgu}}\,(t_1 \iota \sigma,\,t_2 \iota \sigma),\,\delta)\}\\
       %        \emptyset,\;\mbox{if no mgu exists}
       %     \end{array}
       %  \right. \\
      
       \Gamma,\,\iota \vdash \sigma \Xrightarrow{\ocanren{$t_1\;$ === $\;t_2$}} 
         \left\{
            \def\arraystretch{1}
            \begin{array}{l}
               \{\sigma\ \mbox{mgu}\,(t_1 \iota \sigma,\,t_2 \iota \sigma)\}\\
               \emptyset,\;\mbox{if no m.g.u. exists}
            \end{array}
         \right. \\
      
      %\dfrac{ \Gamma,\,\iota[x \leftarrow s] \vdash (\sigma,\,\delta \cup \{s\}) \Xrightarrow{\ocanren{$g$}} S }{ \Gamma, \iota \vdash (\sigma,\,\delta) \Xrightarrow{\ocanren{fresh ($x$) $\;g$}} S },\;s \not\in \delta\\ 
      
\dfrac{ \Gamma,\,\iota\,[x \leftarrow s] \vdash \sigma \Xrightarrow{\ocanren{$g$}} S }{ \Gamma, \iota \vdash \sigma \Xrightarrow{\ocanren{fresh ($x$) $\;g$}} S },\;s\;\mbox{is fresh}\\ 
      
%       \dfrac{\Gamma,\,\iota[x_i\gets t_i\iota\sigma] \vdash (\epsilon,\,\delta) \Xrightarrow{\ocanren{$g$}} \{ (\sigma_j,\,\delta_j) \}}
%             {\Gamma,\,\iota \vdash (\sigma,\,\delta) \Xrightarrow{\ocanren{$r^n \ t_1 \ \dots \ t_n$}} \{ (\sigma \sigma_j,\,\delta_j)\} },\,\Gamma\,(r^n) = \lambda\bar{x_i}.g \\

       \dfrac{\Gamma,\,\iota\,[x_i\gets t_i\iota\sigma] \vdash \epsilon \Xrightarrow{\ocanren{$g$}} \{\sigma_j\}}
             {\Gamma,\,\iota \vdash \sigma \Xrightarrow{\ocanren{$r^n \ t_1 \ \dots \ t_n$}} \{ \sigma \sigma_j\} },\,\Gamma\,(r^n) = \lambda x_1\dots x_n.g \\
      
%       \dfrac{ \Gamma,\, \iota \vdash (\sigma,\, \delta) \Xrightarrow{ \ocanren{$g_1$} } S_1,\; 
%       \Gamma,\, \iota \vdash (\sigma,\, \delta) \Xrightarrow{ \ocanren{$g_2$} } S_2}{ \Gamma,\, \iota \vdash (\sigma,\, \delta) \Xrightarrow{ \ocanren{$g_1\;\vee\;g_2$} } S_1 \cup S_2 } \\

      \dfrac{ \Gamma,\, \iota \vdash \sigma \Xrightarrow{ \ocanren{$g_1$} } S_1,\;\;\; 
       \Gamma,\, \iota \vdash \sigma \Xrightarrow{ \ocanren{$g_2$} } S_2}{ \Gamma,\, \iota \vdash \sigma \Xrightarrow{ \ocanren{$g_1\;\vee\;g_2$} } S_1 \cup S_2 } \\
      
%       \dfrac{ \Gamma,\, \iota \vdash (\sigma,\, \delta) \Xrightarrow{ \ocanren{$g_1$} } \{ (\sigma_i,\, \delta_i)\},\;
%       \Gamma,\, \iota \vdash (\sigma_i,\, \delta_i) \Xrightarrow{ \ocanren{$g_2$} } S_i }{ \Gamma,\,\iota \vdash (\sigma,\, \delta) \Xrightarrow{ \ocanren{$g_1 \wedge g_2$} } \cup_i S_i }

\dfrac{ \Gamma,\, \iota \vdash \sigma \Xrightarrow{ \ocanren{$g_1$} } \{ \sigma_i\},\;\;\;
       \Gamma,\, \iota \vdash \sigma_i \Xrightarrow{ \ocanren{$g_2$} } S_i }{ \Gamma,\,\iota \vdash \sigma \Xrightarrow{ \ocanren{$g_1 \wedge g_2$} } \uplus\,S_i } 
\end{array}
$$

      \begin{center} Only for terminating search! \end{center}
      \begin{exampleblock}{Non-termination test}
        If we meet such configuration
        \[
          \begin{array}{c}
            \Gamma, \iota_1 \vdash (\sigma_2, \delta_2) \Xrightarrow{r^n b_1 \dots b_n} \\
            \ldots \\
            \Gamma, \iota_1 \vdash (\sigma_1, \delta_1) \Xrightarrow{r^n a_1 \dots a_n}
          \end{array}
        \]
        and for some substitution $\tau$
        \[ a_i \iota_1 \sigma_1 = (b_i \iota_2 \sigma_2) \tau \]
        then there is no $S$ such that
        \[ \Gamma, \iota_1 \vdash (\sigma_1, \delta_1) \Xrightarrow{r^n a_1 \dots a_n} S \]
      \end{exampleblock}
      We prove it to be correct.
      
      \textbf{Corollary:} search extention preserves \\ refutational completeness.
    \end{block}
    
    \begin{block}{Implementation details}
      \begin{itemize}
        \item Deep embedding required
        \item $\mathcal{O}(n^2)$ orders are checked in worst case, \\ but optimal can't be missed
        \item Extended search is $10$ times slower \\ on terminating programs at the moment
      \end{itemize}
    \end{block}
    
    \begin{block}{Acknowledgements}
      This work is sponsored by JetBrains Research.
    \end{block}

  \end{column}
  
  \begin{column}{\sepwid}\end{column} % Empty spacer column
\end{columns}

\end{frame} % End of the enclosing frame

\end{document}
