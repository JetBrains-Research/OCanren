
\begin{columns}[t] % The whole poster consists of three major columns, the second of which is split into two columns twice - the [t] option aligns each column's content to the top


\begin{column}{\sepwid}\end{column} % Empty spacer column


\begin{column}{\onecolwid} % The first column

\begin{block}{Relational programming}

Relational programming is a technic of writing programs as relations. It allows using relational programs in unexpected ways.

\begin{figure}
  \begin{tabular}{ | l c l | }
    \hline
    List sorting function & as & List permutations generator          \\
    \hline
    Type checker            & as & Type inferencer or                         \\
                                       &      & Type inhabitation problem solver \\
    \hline
    Interpreter                 & as & Generator of programs by tests   \\
    \hline
  \end{tabular}
\end{figure}

MiniKanren is a family of embedded relational DSLs.

Host languages include:

\begin{itemize}
  \item \textbf{Scheme (original implementation)}
  \item Closure
  \item Haskell
  \item Go
  \item \textbf{OCaml (used implementation)}
\end{itemize}

\end{block}
\begin{block}{Problem}

Complete interleaving search: all existing solutions will be found.

But search can diverge, when no solution exist.

\end{block}

\begin{alertblock}{Goal}

Make it easier to write refutationally complete relations, i.e. programs that always terminate whenever there are finitely many answers.

\end{alertblock}

\begin{block}{Possible approach}

\begin{enumerate}
  \item Advanced technics of writing relations, such as bounding the sizes of terms
  \item Simulation of commutative conjunction evaluation
  \item \textbf{Reordering of conjuncts during evaluation}
\end{enumerate}

\end{block}


\begin{block}{Our approach}

\textbf{Idea:} testing current search proccess for divergence and try different order if it was detected.

This optimization is

\begin{itemize}
  \item online
  \item non-intrusive
  \item conservative
\end{itemize}

\end{block}

\begin{comment}

\begin{block}{Relational programming}

Relational programming is a technic of writing programs as relations. It allows using relational programs in unexpected ways.

\begin{figure}
  \begin{tabular}{ | l c l | }
    \hline
    List sorting function & as & List permutations generator          \\
    \hline
    Type checker            & as & Type inferencer or                         \\
                                       &      & Type inhabitation problem solver \\
    \hline
    Interpreter                 & as & Generator of programs by tests   \\
    \hline
  \end{tabular}
\end{figure}

MiniKanren is a family of embedded relational DSLs.

Host languages include:

\begin{itemize}
  \item \textbf{Scheme (original implementation)}
  \item Closure
  \item Haskell
  \item Go
  \item \textbf{OCaml (used implementation)}
\end{itemize}

\end{block}


\begin{block}{Problem}

Consider relational specification for concatenation of two lists.

\begin{figure}
\begin{lstlisting}
   let rec append$^o$ x y xy =
     (x === [] /\ y === xy) \/
     (fresh (h t)
       (x === h :: t) /\
       (fresh (ty)
		(h :: ty === xy) /\	 (* 1 *)
	  	(append$^o$ t y ty)		(* 2 *)
       )
     )
\end{lstlisting}
\end{figure}

If we use it to get all splitings of given list, search will diverge.

But if we swap conjuncts (1) and (2) execution in any direction will terminate.

Reason: evaluation of conjunction is non-commutative.

In more complex cases, different directions of program execution may require different orders of conjuncts to terminate.

\begin{alertblock}{Goal}

Make it easier to write refutationally complete relations, i.e. programs that always terminate whenever there are finitely many answers.

\end{alertblock}

\end{block}

\begin{block}{Relational programming}

Relational programming is a technic of writing programs as relations. It allows using relational programs in unexpected ways.

\begin{figure}
  \begin{tabular}{ | l c l | }
    \hline
    List sorting function & as & List permutations generator          \\
    \hline
    Type checker            & as & Type inferencer or                         \\
                                       &      & Type inhabitation problem solver \\
    \hline
    Interpreter                 & as & Generator of programs by tests   \\
    \hline
  \end{tabular}
\end{figure}

MiniKanren is a family of embedded relational DSLs.

Host languages include:

\begin{itemize}
  \item \textbf{Scheme (original implementation)}
  \item Closure
  \item Haskell
  \item Go
  \item \textbf{OCaml (used implementation)}
\end{itemize}

\end{block}


\begin{block}{Problem}

Consider relational specification for concatenation of two lists.

\begin{figure}
\begin{lstlisting}
   let rec append$^o$ x y xy =
     (x === [] /\ y === xy) \/
     (fresh (h t)
       (x === h :: t) /\
       (fresh (ty)
		(h :: ty === xy) /\	 (* 1 *)
	  	(append$^o$ t y ty)		(* 2 *)
       )
     )
\end{lstlisting}
\end{figure}

If we use it to get all splitings of given list, search will diverge.

But if we swap conjuncts (1) and (2) execution in any direction will terminate.

Reason: evaluation of conjunction is non-commutative.

In more complex cases, different directions of program execution may require different orders of conjuncts to terminate.

\begin{alertblock}{Goal}

Make it easier to write refutationally complete relations, i.e. programs that always terminate whenever there are finitely many answers.

\end{alertblock}

\end{block}

\end{comment}

\end{column} % End of the first column


\begin{column}{\sepwid}\end{column} % Empty spacer column


\begin{column}{\onecolwid} % Begin a column which is two columns wide (column 2)

\begin{block}{Language}

Relations in MiniKanren are represented by \textbf{goals} that can be built with the aid of a few simple combinators.

\begin{itemize}
  \item $t_1 \equiv t_2$ \quad unification of two terms
  \item $g_1 \wedge g_2$ \quad conjunction of two goals
  \item $g_1 \vee g_2$ \quad disjunction of two goals
  \item {\ttfamily{\underbar{fresh}}} $(x) \ g$ \quad introduction of fresh logic variable
  \item $r^n \ t_1 \dots t_n$ \quad call for previously defined relation
\end{itemize}

\begin{comment}



Classical MiniKanren relation example is concatenation of two lists.

\begin{figure}
\begin{lstlisting}
   let rec append$^o$ x y xy =
     (x === [] /\ y === xy) \/
     (fresh (h t)
       (x === h :: t) /\
       (fresh (ty)
	  	(append$^o$ t y ty)		(* 1 *)
		(h :: ty === xy) /\	 (* 2 *)
       )
     )
\end{lstlisting}
\end{figure}

We can use this definition to find concatenation

\begin{figure}
\begin{lstlisting}
run 1 (fun q -> append$^o$ [1; 2] [3] q) $\leadsto$ {q=[1; 2; 3]}
\end{lstlisting}
\end{figure}

or to find splitings of the list

\begin{figure}
\begin{lstlisting}
run 3 (fun q r -> append$^o$ q r [1; 2; 3]) $\leadsto$
{q=[], r=[1; 2]; q=[1], r=[2]; q=[], r=[1; 2]}
\end{lstlisting}
\end{figure}

We also can request all answers.

\begin{figure}
\begin{lstlisting}
run * (fun q r -> append$^o$ q r [1; 2; 3])
\end{lstlisting}
\end{figure}

But this query diverges.

The reason is non-comutativity of conjunction.

There we can swap last two goals and get refutationally complete relation. But it won't work in more complicated examples.

\end{comment}

\end{block}

\begin{block}{Examples}

Good example to feel the problem is relational list sorting

\begin{figure}
\begin{lstlisting}
let minmax$^o$ a b min max =
  (min ===  a /\ max === b /\ le$^o$ a b) \/
  (min ===  b /\ max === a /\ gt$^o$ a b)

let rec smallest$^o$ l s l' =
  (l === [s] /\ l' === []) \/
  (fresh (h t s' t' max) (
    (l === h :: t) /\
    (l' === max :: t') /\
    (minmax$^o$ h s' s max) /\
    (smallest$^o$ t s' t')
  ))

let rec sort$^o$ =
  (xs === [] /\ ys === []) \/
  (fresh (s xs' ys') (
    (ys === s :: ys') /\
    (smallest$^o$ xs s xs')	/\
    (sort$^o$ xs' ys')
	))
\end{lstlisting}
\end{figure}

We can use this definition to actually sort a list

\begin{figure}
\begin{lstlisting}
run 1 (fun q -> sort$^o$ [3; 2; 1] q) $\leadsto$ {q=[1; 2; 3]}
\end{lstlisting}
\end{figure}

or to find permutations of given sorted list

\begin{figure}
\begin{lstlisting}
run 2 (fun q -> sort$^o$ q [1; 2]) $\leadsto$ {q=[1; 2]; q=[2; 1]}
\end{lstlisting}
\end{figure}

We also can request all answers, not fixed number of them.

\begin{figure}
\begin{lstlisting}
run * (fun q -> sort$^o$ [3; 2; 1] q) $\leadsto$ {q=[1; 2; 3]}

run * (fun q -> sort$^o$ q [1; 2])
\end{lstlisting}
\end{figure}

But for the last query the program will diverge.

We can swap last two conjuncts in definition to fix it, but then previous query will lead to divergence.

The reason is \textbf{non-comutativity of conjunction}.

Fuction call get only information recieved by this point, wich can lead to divergence.

In this case, non-termination test will signal divergence in less informative call and optimized search will pull out more informative call ahead, making this sorting relation refutationally complete.

This automatic order choice gives opportunity to write easier definitions, as if conjunction was commutative, and still get terminating programs.

For example, consider the definition of division with reminder for binary numbers from MiniKanren standart library.

\begin{figure}
\begin{lstlisting}
let rec div$^o$ n m q r =
  (r === n /\ [] === q /\ plus$^o$ r m n /\ lt$^o$ r m) \/
  ([1] === q /\ eql$^o$ n m /\ plus$^o$ r m n /\ lt$^o$ r m) \/
  ((ltl$^o$ m n) /\ (lt$^o$ r m) /\ (pos$^o$ q) /\
   (fresh (nh nl qh ql qlm qlmr rr rh) (
     (split$^o$ n r nl nh) /\
     (split$^o$ q r ql qh) /\
     ((([] === nh) /\ ([] === qh) /\
       (minus$^o$ nl r qlm) /\ (mult$^o$ ql m qlm)) \/
      ((pos$^o$ nh) /\ (mult$^o$ ql m qlm) /\
       (plus$^o$ qlm r qlmr) /\ (minus$^o$ qlmr nl rr) /\
       (split$^o$ rr r [] rh) /\ (div$^o$ nh m qh rh))
     )
   ))
  )
\end{lstlisting}
\end{figure}

The technic of bounding term sizes is used here to achieve refutational completeness. It's quite tricky and takes a bit of inspiration to write.

In contrast, optimized search provides much more straightforward variant.

\begin{figure}
\begin{lstlisting}
let div$^o$ n m q r =
  fresh (qm) (
    (pos$^o$ m) /\ (pos$^o$ qm) /\
    (lt$^o$ r m) /\ (mult$^o$ q m qm) /\
    (plus$^o$ qm r n)
  )
\end{lstlisting}
\end{figure}

\end{block}

\begin{comment}

\begin{block}{Possible solutions}

\begin{enumerate}
  \item Advanced technics of writing relations, such as bounding \\ the sizes of terms
  \item Simulation of commutative conjunction evaluation
  \item \textbf{Reordering of conjuncts during evaluation}
\end{enumerate}

\end{block}


\begin{block}{Conjuncts reordering approach}

\textbf{Idea:} testing current search proccess for divergence and try different \\  order of conjuncts if it was detected.

This optimization is

\begin{itemize}
  \item online
  \item non-intrusive
  \item conservative
\end{itemize}

\end{block}


\begin{block}{Results}

We present prototype implementation of optimized search and number of naive relational solutions for different problems.

\begin{itemize}
  \item List reversing
  \item List sorting
  \item Multiplication of Peano numbers
  \item Binary arithmetic (including addition, multiplication, division \\ and comparisons)
\end{itemize}

These relations are refutationally complete with optimized search, \\ regardless of the order of goals.

At the same time, for all problems the naive solutions are known not to be refutationally complete with non-optimized search.

\end{block}

\end{comment}

\end{column}


\begin{column}{\sepwid}\end{column}


\begin{column}{\onecolwid}

\begin{block}{MiniKanren semantics}

\end{block}

\begin{block}{Non-termination test}

\end{block}

\begin{block}{Implementation details?}

\end{block}

\begin{block}{Results?}

\end{block}

\begin{block}{References?}

\end{block}

\begin{block}{acknowledgements?}

\end{block}

\begin{comment}

\begin{block}{Non-termination test}

For description and proof purposes we describe specific big-step operational semantics for miniKanren, which cover only the case of evaluation with finitely many answers.

\[ \Delta \vdash \sigma \xRightarrow{g} S \]

Which means that evaluation of specification $g$ with initial substitution $\sigma$ and functions definitions $\Delta$ terminates with set of answers $S$.

We chose following observation as non-termination test:

\begin{alertblock}{Non-termination criterion}

If during the derivation of some branch we arrived at the
following configuration

$$
\begin{array}{c}
  \Delta\vdash\sigma_2\xRightarrow{f(x_1,\dots,x_n)}\\
  \ldots\\
  \Delta\vdash\sigma_1\xRightarrow{f(y_1,\dots,y_n)}
\end{array}
$$

and there is some substitution $\tau$, such that $y_i\sigma_1=(x_i\sigma_2)\tau$, then there is no $S$, such that $\Delta\vdash\sigma_2\xRightarrow{f(x_1,\dots,x_n)} S$.

\end{alertblock}

And formally proved it.

As a consequence, our optimization preserves refutational completeness.

\end{block}


\begin{block}{Implementation details}

\begin{enumerate}
  \item Deep embedding of relational language required
  \item Only a small proportion of orders are considered during conjuncts reordering, but we garantee to never miss order that leads to termination
  \item Optimized implementation preserves lazy interface of answers by tracing them, wich makes current version much slower than non-optimized one on terminating programs
\end{enumerate}

\end{block}

\end{comment}

\end{column}


\end{columns} % End of all the columns in the poster

