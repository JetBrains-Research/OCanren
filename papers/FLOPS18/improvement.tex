\section{Search Improvement}
\label{improvement}

As we've seen in the previous section, the non-commutativity of conjunction is one of the reasons for
refutational incompleteness (the other one is recursion). Switching arguments of a certain conjunction
can sometimes improve the results; there is, however, no certain static order,
beneficial in all cases. Thus, we can make the following observations:

\begin{itemize}
\item the conjuction to change has to be properly identified;
\item the order of conjuncts has to be a subject of a \emph{dynamic} choice.
\end{itemize}

Our improvement of the search is based on the idea of switching the order of conjuncts only when
the divergence of the first one is detected. More specifically: 

\begin{itemize}
\item during the search, we keep the track of all conjunctions being performed;
\item when we detect the divergence, we roll back to the nearest conjunction, switch their
constituents, and rerun the search.
\end{itemize}

We also need to pay a special attention to make it possible to enumerate all orders of all conjuncts in
compound conjunctions, not only immediate one; thus, in \mbox{$(g_1\wedge g_2)\wedge g_3$} we should
be able to try not only \mbox{$(g_1\wedge g_2)\wedge g_3$} and \mbox{$g_3 \wedge(g_1\wedge g_2)$}, but, 
for example, \mbox{$(g_2\wedge g_1)\wedge g_3$}, etc. Moreover, all orders, tried so far, have to be
memorized. When we tried out every one, we need to proceed to the next enclosing conjunction (if any).
Note, in this approach we modify the conjunctions according to their dynamic evaluation order, not static
scoping. 

The important detail is the divergence test. Of course, due to the fundamental results in computability
theory, there is no hope to find a \emph{precise} computable test, which constitutes the necessary and 
sufficient condition of divergence. However, in our case a sufficient condition is sufficient. Indeed,  
a sufficient condition identifies a case, when the search, being continued, will lead to an incompleteness 
(since a divergence in our semantics always means incompleteness). Thus, it is no harm to try some other way. 

We can introduce the following notion to compare two search strategies w.r.t. refutational completeness: 
we say, that a strategy $B$ is a \emph{refutational improvement} of a strategy $A$, if arbitrary
query $Q$, refutationally complete w.r.t. $A$, it is also refutationally complete w.r.t. $B$, and there
is a query $Q^\prime$, which is refutationally incomplete w.r.t. $A$ and refutationally complete
w.r.t. $B$. 

We are going the present now a sufficient test for a divergency, and prove, that our modification of
the search constitutes a (limited) refutational improvement for queries, returning only a finite number of answers.

Our divergence test is based on the following notion:

\begin{definition}
\normalfont 
We say, that a vector of terms $\overline{a^{\phantom{x}}_i}$ is more general, than a vector of terms $\overline{b^{\phantom{x}}_i}$ (notation 
$\overline{a^{\phantom{x}}_i}\succeq\overline{b^{\phantom{x}}_i}$), if there is a substitution $\tau$, such that for $\forall i\;b_i = a_i \tau$.
\end{definition}

The idea of the test is rather simple: it identifies a recursive call with more general arguments, 
than (some) enclosing one. 


\begin{theorem}[Divergence criterion]
\normalfont
For any well-formed semantic statement 

$$
\otrans{\Gamma,\iota}{(\sigma,\,\delta)}{r^k\,t_1\dots t_k}{S}
$$ 

if its proper derivation subtree has a semantic statement 

$$
\otrans{\Gamma,\iota^\prime}{(\sigma^\prime,\,\delta^\prime)}{r^k\,t^\prime_1\dots t^\prime_k}{S^\prime}
$$

then $\overline{t^\prime_i \iota^\prime \sigma^\prime} \not \succeq \overline{t^{\phantom{\prime}}_i \iota \sigma}$. 
\end{theorem}
\begin{proof}
Immediately follows from Lemmas~\ref{one},~\ref{three}.~$\Box$
\end{proof}
