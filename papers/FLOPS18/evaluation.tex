\section{Implementation and Evaluation}
\label{evaluation}

We implemented the improved version of the search, described in the previous section, 
as a prototype over existing miniKanren implementation for OCaml, called OCanren~\cite{OCanren}. 
For the simplicity, we switched to a deep embedding (most miniKanren implementations, 
including OCanren, use shallow embedding), and changed the syntax to make relational definitions
visible for the interpreter. Programs in OCanren can be easily converted to respect 
the new syntax.

With this implementation, we became capable to evaluate a number of useful, but refutationally 
incomplete miniKanren relations, including those considered earlier. In all cases the 
improved search managed to discover the divergence and fix the incompleteness, caused by
the non-commutativity of conjuction; moreover, the performance of some queries was improved 
significantly. In the following subsections we consider some interesting cases.

\subsection{Relations on lists}

As we have seen in Section~\ref{incompleteness}, for some simple relations, like \lstinline|append$^o$|,
a recursive call has to be placed last in the sequence of conjuncts in order for the 
relation to be refutationally complete. Specifically for \lstinline|append$^o$|, with the improved search 
the divergence is discovered and refutational incompleteness is fixed regardless the position of 
the recursive call.

As a more interesting example we consider the \lstinline|revers$^o$| relation. As we've
seen, in order for different queries to work it requires different orders of conjuncts 
to be used in the implementation. Again, the improved search lifts this requirement.
Even more interesting, that, for example, in the query 

\begin{lstlisting}
   fresh ($q$) (revers$^o$ (Cons (A, Nil)) $q$)
\end{lstlisting}

\noindent the divergence is discovered for the recursive call of \lstinline|appendo$^o$|, but,
as none of conjunct orders within the definition of \lstinline|append$^o$| help, the
improved search goes even more back and switches the conjuncts within the definition of
\lstinline|revers$^o$|. This example demonstrates the importance of operating on 
dynamic invocation order.

Another example we've already looked at is relational sorting/permutations. 
With the improved search, both queries \lstinline|fresh ($q$) (perm$^o$ l $q$)| and 
\lstinline|fresh ($q$) (perm$^o$ $q$ l)| terminate for any list \lstinline|l| of a reasonable 
length (7, 8, etc.), and now work in a reasonable time. Moreover, now
relational permutations can be used as a (we admit, somewhat exotic) way to calculate 
the number of permutations with repetitions.

\subsection{Arithmetic}

The implementation of a relational arithmetic is an important problem, since it is required
in a number of elaborated relational specifications. For performance reasons, it is 
preferrable to use binary numbers, not comfy Peano encoding, which makes the problem 
more complicated. As it is shown in~\cite{WillThesis}, the naive implementation of 
binary arithmetic is inapproptiate due to multiple problems. 

Fixing these problems take a lot of efforts: it requires some additional conditions, 
excess on the first glance, to be introduced in the specification to ensure the non-overlapping 
of cases and correctness of number representation. And still, even with all these 
improvements, arithmetic relations diverge for some routine queries with one order of 
consituents, and for others with another. To overcome this problem, 
arithmetics in the standard miniKanren implementation~\cite{TRS} uses digital logic and 
some advanced techniques of bounding the sizes of the terms~\cite{KiselyovArithmetic}. 
As a result, the implementation is quite complicated and takes time to understand.

At the same time, all these problems are exactly the consequences of the non-commutativity 
of conjunction. So, as expected, the improved search 
strategy allows to use refutationally incomplete versions of binary arithmetic relations (for addition, 
multiplication, comparisons, division with a reminder) without these complicated optimisations and still 
get the desired behaviour. 

As the brightest example, for the division with reminder, instead of a very complicated recursive definition 
from~\cite{TRS} (20 lines of code, not including auxiliary functions), one can just right down the 
following definition

\begin{lstlisting}
   div$^o$ $\binds$ $\lambda\;x\;y\;q\;r$ . 
     (fresh (yq)        
        (mult$^o$ $y$ $q$ $yq$) /\
        (plus$^o$ $yq$ $r$ $x$) /\
        (lt$^o$ $r$ $y$)
     )
\end{lstlisting}

\noindent and for all queries

\begin{lstlisting}
   fresh ($q$ $r$) (div$^o$ $\overline{23}$ $\overline{5}$ $q$ $r$)
   fresh ($y$ $q$ $r$) (div$^o$ $\overline{19}$ $y$ $q$ $r$)
   fresh ($x$ $r$) (div$^o$ $x$ $\overline{17}$ $\overline{4}$ $r$)
\end{lstlisting}

\noindent the search terminates and shows the preformance, comparable with the advanced version 
(here $\overline{n}$ denotes a binary representation of the number $n$).

\subsection{Binary trees}

For natural representation of binary trees using two constructors: \lstinline|Leaf| and \lstinline|Node($l$, $r$)| it is easy to construct relation counting number of leaves in it (using addition relation from arithmetic):

\begin{lstlisting}
   siz$^o$ $\binds$ $\lambda\;t\;s$ .
     (($t$ === $\;\;$Leaf) /\ ($s$ === $\;\;$$\overline{1}$)) \/
     (fresh ($l$ $r$ $sl$ $sr$)
        ($t$ === $\;$Node ($l$, $r$)) /\
        (siz$^o$ $l$ $sl$) /\
        (siz$^o$ $r$ $sr$) /\
        (plus$^o$ $sl$ $sr$ $s$)
     )
\end{lstlisting}

By running this relation ``bacwards'':

\begin{lstlisting}
   fresh ($q$) (siz$^o$ $q$ $\overline{n}$)
\end{lstlisting}

\noindent we are able to generate all binary trees with given number of leaves $n$. Improved search strategy ensures termination of this query (as long, as \lstinline|plus$^o$| terminates in both directions), and the number of discovered answers is the number of such trees, so this relational program may be seen as a freaky way of calculation Catalan numbers.

\subsection{Interpreters}

Program synthesis with relational interpreters are some of the most useful applications of miniKanren. The construction of relational interpreter for small Scheme-like language is considered 
in detail in~\cite{Untagged}. This simple interpreter also has some problems with non-commutativity, however. For example, such obviously contradictory queries as

\begin{lstlisting}
   fresh ($e1$ $e2$ $r1$ $r2$) (eval$^o$ (list $e_1$ 3 $e_2$) Nil ($r_1$ 4 $r_2$))
\end{lstlisting}

\noindent will lead to divergence under coventional search strategy (no simple reordering can fix it). Under improved search strategy conradiction will be found and search will terminate. Relational interpreters used in practice for complex problems~\cite{unified} include lots of optimisations and take significant effort to implement. We hope, that some performance problems with them are caused by non-commutativity and can be fixed automatically by improved search strategy.
