


\newcommand{\head}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}}{\textbf{#2}}}
\newcommand{\headll}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}||}{\textbf{#2}}}
\newcommand{\headl}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}|}{\textbf{#2}}}

\begin{table}[t]
  \caption{The results of synthesis evaluation}\label{fig:eval}
    
  %\begin{tabular}{|c|m{3cm}|cc||cccc}
  \begin{tabular}{|m{3cm}|cc||cccc|}
\hline
%    \headl{.5cm}{}    &
    \headl{3cm}{Patterns} & 
    \head{1.5cm}{Size constraint} & 
    \headll{1.7cm}{Answers requested} & 
    \head{2cm}{Number of samples} & 
    \head{1.5cm}{1st answer time (ms)} & 
    \head{1.5cm}{Answers found} & 
    \head{1.5cm}{Total search time (ms)}\\
    \hline
    \hline
    %1&
    \begin{lstlisting}[basicstyle=\scriptsize]
A
B
C
    \end{lstlisting} &100&all&3&1&1&1\\
        \hline
%        2&
    \begin{lstlisting}[basicstyle=\scriptsize]
true
false
    \end{lstlisting} &100&all&2&<1&1&<1\\
        \hline
%        3&
            \begin{lstlisting}[basicstyle=\scriptsize]
(true, _)
(_, true)
(false, false)
    \end{lstlisting} &100&all&4&6&2&10\\
        \hline
%        4&
     \begin{lstlisting}[basicstyle=\scriptsize]
(_, false, true)
(false, true, _)
(_, _, false)
(_, _, true)
    \end{lstlisting} &100&all&8&323&3&729\\
        \hline
%        5&
     \begin{lstlisting}[basicstyle=\scriptsize]
([], _)
(_, [])
(_ :: _, _ :: _)
    \end{lstlisting} &100&10&4&5&1&6\\
        \hline
%        6&
     \begin{lstlisting}[basicstyle=\scriptsize]
(Succ _, Succ _)
(Zero, _)
(_, Zero)
    \end{lstlisting} &1&all&4&53&2&108
    \\
        \hline
%        \mbox{7}&
        \multirow{3}{*}{
          \parbox{3cm}{
            \vskip2mm
\lstinline[basicstyle=\scriptsize]|(Nil, _)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(_, Nil)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(Nil2, _)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(_, Nil2)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(_ :: _, _ :: _)|}}
         & 1&10&9&643&2&3776\\[3mm]
        \cline{2-7}
      &10&10&9&95&2&540\\[3mm]
        \cline{2-7}
     &100&10&9&45&2&239                    \\ \hline
  \end{tabular}

\end{table}

%\FloatBarrier

\section{Implementation and Optimizations}
\label{sec:optimization}

In this section we address two aspects of our solution: a number of optimizations which make the search more efficient, and
the way it ends up with the optimal solution.

The relational goal in its final form, presented in the previous section, does not demonstrate good performance. Thus, we apply a number
of techniques, some of which require extending the implementation of the search. Namely, we apply the following optimizations:

\begin{itemize}
\item We make use of type information to restrict the subset of constructors which may appear in a certain branch of
  program being synthesized.
\item We implement \emph{structural constraints} which allow us to restrict the shape of terms during the search, and
  utilize them to implement pruning.  
\end{itemize}

In our formalization we do not make any use of types since as a rule type information does not affect matching. In addition,
utilizing the properties of a concrete type system would make our approach too coupled with this particular type system, hampering
its reusability for other languages. Nevertheless we may use a certain abstraction of type system which would deliver only
that part of information which is essential for our approach to function. Currently, we calculate the type of any matching expression in
the program being synthesized and from this type extract the subset of constructors which can appear when branching on this expression
is performed. The number of these constructors restricts the number of branches which a corresponding $\primi{switch}$ expression can have.
In our implementation we assume the constructor set ordered, and we consider only ordered branches, which restricts branching even more.

Our approach to finding an optimal solution in fact implements branch-and-bound strategy. The birds-eye view of our plan is as follows:

\begin{itemize}
\item We construct a trivial solution, which gives us the first estimation.
\item During the search we prune all partial solutions whose size exceeds current estimation. We can do this due to
  the top-down nature of partial solution construction.
\item When we come up with a better solution we remember it and update current a estimate.
\end{itemize}

\noindent This strategy inevitably delivers us the optimal solution since there are only finitely many switch programs, shorter than trivial solution.

In order to implement this strategy we extended \textsc{OCanren} with a new primitive called \emph{structural constraint}, which may
fail on some terms depending on some criterion specified by an end-user. Structural constraints can be seen as a generalization of
some known constraints like \lstinline|absent$^o$| or \lstinline|symbol$^o$|~\cite{Untagged} in existing \textsc{miniKanren} implementations, 
so they can be widely used in solving other problems as well. Note, we could implement other constraints we considered (on the
depth of switch programs, on the type of scrutinee) as structural\footnote{\textcolor{red}{I don't entirely understand this sentence}}. However, our experience has shown that this leads to
a less efficient implementation. Since these constraints are inherent to the problem, we kept them ``hard coded''.


\subsection{Reducing a Complete Set of Samples}
\label{sec:reduced-samples}

Although, in the general case an exponential number of samples is required, in corner cases a complete set of examples can be minimized. For example, for the following pattern matching 

\begin{lstlisting}
match (x : (int list  * int list)) with 
| (_, _ :: _ :: _) -> ...
| (_, _ :: _)      -> ...
\end{lstlisting}

\noindent synthesized program should not investigate left subtree of scrutinee because original pattern matching doesn't care about contents of this subtree and removing this check will give shorter (i.e. more optimal) solution.

Possible matchable values  from $\mathcal{M}$ that appear in programs from  $\mathcal{S}$  should also be restricted by the same arguments that are described in section \ref{sec:samples}. The set $s^\cup$ of these possible matchable values, that essentially describe paths to "interesting" subexpressions of the scrutinee, can be computed statically before synthesis procedure.

\[
\begin{array}{rcl}
   s\,(m, C\ p_1 \dots p_k)     & = & \{m\}\cup \bigcup\limits_{i=1}^{k} s(m[i], p_i)\\
   s\,(m,\_)                 & = & \varnothing \\
   s^\cup\,(p_1,\dots, p_k) & = & \bigcup\limits_{i=1}^{k} s(\bullet, p_i)
\end{array}
\]

\noindent For the example above, the set  $s^\cup$ will be 
$\{\bullet, \bullet[1], \bullet[1][1]\}$. The complete set of examples could be the following 3-element set:
\lstinline=($\underline{[]}$, [])=, \lstinline=($\underline{[]}$, $\underline{42}$ :: [])= and  \lstinline=($\underline{[]}$, $\underline{42}$ :: $\underline{42}$ :: $\underline{[]}$)= where underlined expression are chosen arbitrarily. The straightforward algorithm from the section \ref{sec:samples} would geenrate the larger set of $3^2$ examples.

The set $s^\cup$ can be used for sample enumeration, for example, in the following manner. During enumeration we keep current matchable that will be used to access current subtree of the sample. If that matchable $\notin s^\cup$ we can put arbitrary inhabitant here. And if not then we perform structural recursion for all possible constructors of this subexpresion.

The correctness of the algorithm relies on the fact that if matchable  $m \notin s^\cup$ then all extensions of $m$ that look deeper in that subtree also $\notin s^\cup$. It means that further reductions of $s^\cup$ set should be performed after samples enumeration. These reductions could be, for example, removing matchables that point to subexpressions which always start from single constructor (like tuples).

