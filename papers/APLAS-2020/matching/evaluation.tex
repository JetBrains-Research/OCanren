\newcommand{\lheadl}[2]{\multicolumn{1}{|>{\centering\arraybackslash}m{#1}|}{\textbf{#2}}}
\newcommand{\head}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}}{\textbf{#2}}}
\newcommand{\headll}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}||}{\textbf{#2}}}
\newcommand{\headl}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}|}{\textbf{#2}}}

\begin{table}[t]
  \caption{The results of synthesis evaluation}\label{fig:eval}
    
  %\begin{tabular}{|c|m{3cm}|cc||cccc}
  \begin{tabular}{|m{3cm}|cc||cccc|}
\hline
%    \headl{.5cm}{}    &
    \lheadl{3cm}{Patterns} & 
    \head{1.5cm}{Size constraint} & 
    \headll{1.7cm}{Answers requested} & 
    \head{2cm}{Number of samples} & 
    \head{1.5cm}{1st answer time (ms)} & 
    \head{1.5cm}{Answers found} & 
    \headl{1.5cm}{Total search time (ms)}\\
    \hline
    \hline
    %1&
    \begin{lstlisting}[basicstyle=\scriptsize]
A
B
C
    \end{lstlisting} &100&all&3&1&2&2\\
        \hline
%        2&
    \begin{lstlisting}[basicstyle=\scriptsize]
true
false
    \end{lstlisting} &100&all&2&$<$1&1&$<$1\\
        \hline
%        3&
            \begin{lstlisting}[basicstyle=\scriptsize]
(true, _)
(_, true)
(false, false)
    \end{lstlisting} &100&all&4&5&1&6\\
        \hline
%        4&
     \begin{lstlisting}[basicstyle=\scriptsize]
(_, false, true)
(false, true, _)
(_, _, false)
(_, _, true)
    \end{lstlisting} &100&all&8&1s&3&2s\\
        \hline
%        5&
%     \begin{lstlisting}[basicstyle=\scriptsize]
%([], _)
%(_, [])
%(_ :: _, _ :: _)
%    \end{lstlisting} &100&10&4&5&1&6\\
%        \hline
%        6&
     \begin{lstlisting}[basicstyle=\scriptsize]
(Succ _, Succ _)
(Zero, _)
(_, Zero)
    \end{lstlisting} &1&all&4&30&1&30
    \\
        \hline
%        \mbox{7}&
        \multirow{3}{*}{
          \parbox{3cm}{
            \vskip2mm
\lstinline[basicstyle=\scriptsize]|(Nil, _)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(_, Nil)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(Nil2, _)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(_, Nil2)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(Cons (_, _),Cons(_, _))|}}
         & 1&10&9&388&3&2.6s\\[3mm]
        \cline{2-7}
      &10&10&9&55&3&367\\[3mm]
        \cline{2-7}
     &100&10&9&24&3&157                    \\ 
      \hline
     \begin{lstlisting}[basicstyle=\scriptsize]
(_,_, (Ldi _)::_)
(_,_, (Push _)::_)
    \end{lstlisting} &777&all&5&11&1&30\\
        \hline      
        \multirow{3}{*}{
          \parbox{3cm}{
            \vskip2mm
\lstinline[basicstyle=\scriptsize]|(_,_, (Ldi _)::_)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(_,_, (Push _)::_)|\\[-1mm]
\lstinline[basicstyle=\scriptsize]|(Int(_),_, (IOp _)::_)|\\[-1mm]
}}
     &100&all&20&1.7s&3&11s                    \\[3mm]
             \cline{2-7}
     &777&all&20&1.3s&3&11s\\ \hline
  \end{tabular}

\end{table}

\FloatBarrier

\section{Evaluation}
\label{sec:eval}

%In the table~\ref{fig:eval} we summarize benchmarking results for our synthesis algorithm.

We performed an evaluation of the pattern matching synthesizer on a number of benchmarks.
The majority of benchmarks were prepared manually; we didn't use any specific benchmark sets mentioned in literature~\cite{Scott2000WhenDM} yet.
The 4th benchmark was taken from~\cite{maranget2008}, we used it in Section~\ref{sec:intro} as the first example. 
The evaluation was performed on a desktop computer with Intel Core i7-4790K CPU @ 4.00GHz processor and 8GB of memory,
\textsc{OCanren} was compiled with \mbox{ocaml-4.07.1+fp+flambda}. All benchmarks were executed in the native mode ten times,
then average monotonic clock time was taken. The results of the evaluation are shown on Figure~\ref{fig:eval}.

In the table the double bar separates input data from output. Inputs are: the patterns used for synthesis,
the requested number of answers and the pruning factor. For example, in the first benchmark pruning factor equals 100 which means that structural constraint is checked every 100 unifications. Outputs are: the size of generated complete samples set, the running time before receiving the
first answer, the total number of programs synthesized, the total search time.

Our approach currently does not work fast on a large benchmark. On Fig.~\ref{fig:pcf} we cite an example extracted from a bytecode
machine for PCF~\cite{Plotkin1977LCFCA,maranget2008}. For such complex examples (in terms of type definition complexity and number and size of patterns)
both the size of the search space and the number of samples is too large for our approach to work so far.

%The first conclusion can be drawn from results is that a often checking of the current approximation of the answer by size constraint
%cab lead to performance degradation because this check is not cheap. But we shouldn't do this check infinitely more seldom. It lead to performance degradation too,
%because more search branches will be prunes later.

%The 4th and 7th benchmarks have similar input configurations and examples count but time differs linearly. This probably means that interleaving search of
%OCanren can be more lucky in some cases then in another.

\begin{figure}%[H]
\centering
\begin{tabular}{c} % tabular only for centering

%type code = Push | Ldi of int | IOp of int | Int of int 
%type stack_item = Val of code | Env of int | Code of int 
%type t = code * stack_item list * code list
\begin{lstlisting}
let rec run  s c e =
  match s,c,e with
  | (_,_,Ldi i::_) -> 1
  | (_,_,Push::_)  -> 2
  | (Int _,Val (Int _)::_,IOp _::_) -> 3
  | (Int _,_,Test (_,_)::c) -> 4
  | (Int _,_,Test (_,_)::c) -> 5
  | (_,_,Extend::_) -> 6
  | (_,_,Search _::_) -> 7
  | (_,_,Pushenv::_) -> 8
  | (_,Env e::s,Popenv::_) -> 9
  | (_,_,Mkclos cc::_) -> 10
  | (_,_,Mkclosrec _::_) -> 11
  | (Clo (_,_), Val _::_, Apply::_) -> 12
  | (_,(Code _::Env _::_),[]) -> 13
  | (_,[],[]) -> 14
\end{lstlisting}
\end{tabular}
\caption{An example from a bytecode machine for PCF}
\label{fig:pcf}
\end{figure}

