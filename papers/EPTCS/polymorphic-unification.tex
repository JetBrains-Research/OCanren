\section{Polymorphic Unification}
\label{polyuni}

We consider it rather natural to employ polymorphic unification in the language, already equipped 
with polymorphic comparison~--- a convenient, but somewhat disputable\footnote{See, for example, 
\url{https://blogs.janestreet.com/the-perils-of-polymorphic-compare}} feature. Like polymorphic comparison, 
polymorphic unification performs a traversal of values, exploiting intrinsic knowledge of their runtime 
representation. The undeniable benefits of this solution are, first, that in order to perform unification 
for user types no ``boilerplate'' code is needed, and, second, that this approach seems to deliver the
most efficient implementation. On the other hand, all pitfalls of polymorphic comparison are inherited as 
well; in particular, polymorphic unification loops for cyclic data structures and does not work for functional 
values. Since we generally do not expect any reasonable outcome in these cases, the only remaining problem is that
the compiler is incapable of providing any assistance in identifying and avoiding them. Another drawback is that 
the implementation of polymorphic unification relies on runtime representation of values and have to be fixed 
every time the representation changes.  Finally, as it is written in unsafe manner using \lstinline{Obj} interface, 
it has to be carefully developed and tested.

An important difference between polymorphic comparison and unification is that the former only inspects its operands, 
while the results of unification are recorded in a substitution (a mapping from logical variables to terms), which 
later is used to refine answers and reify  constraints. So, generally speaking, we have to show that no ill-typed 
terms are constructed as a result. Overall, this property seems to be maintained vaciously, since the very 
nature of (syntactic) unification is to detect, whether some thing can be considered equal. Nevertheless there are
different type systems and different unification implementations; in addition \emph{equal things} can be
\emph{differently typed}, so we provide here a correctness justification for a well-defined abstract case, and will 
reuse this conclusion for various concrete cases.

First, we consider three alphabets:

$$
\begin{array}{rcl}
  \tau,\dots&-&\mbox{types}\\
  x^\tau,\dots&-&\mbox{typed logic variables}\\
  C_k^{\tau_1\times\tau_2\times\dots\times\tau_k\to\tau} (k\ge 0),\dots&-&\mbox{typed constructors}
\end{array}
$$

The set of all well-formed typed terms is defined by mutual induction for all types:

$$
t^\tau=x^\tau\mid C_k^{\tau_1\times\tau_2\times\dots\times\tau_k\to\tau}(t^{\tau_1},\,t^{\tau_2},\,\dots,\,t^{\tau_k})
$$

For simplicity from now on we abbreviate the notation $C_k^{\tau_1\times\tau_2\times\dots\times\tau_k\to\tau}(t^{\tau_1},\,t^{\tau_2},\,\dots,\,t^{\tau_k})$ into 
$C_k^\tau(t^{\tau_1},\,t^{\tau_2},\,\dots,\,t^{\tau_k})$, keeping in mind, that for any concrete constructor and for all its occurrencies 
in arbitrary terms all its subterms in corresponding positions agree in types. 

\begin{comment}
We need also to define the notion of a subterm  $t^\tau[p]$ of a term $t^\tau$ at given position $p$:

$$
\begin{array}{rcl}
 p=\epsilon\mid\{1, 2, 3,\dots\}\bullet p&-&\mbox{the set of positions}\\
 t^\tau[\epsilon]=t^\tau&-&\mbox{base case}\\
 C_k^\tau(t_1^{\tau_1},\,t_2^{\tau_2},\dots,\,t_k^{\tau_k})[i\bullet p]=t_i^{\tau_i}[p], 1\le i \le k&-&\mbox{inductive case}
\end{array}
$$
\end{comment}

In this formulation we do not consider any structure over the set of types besides type equality, and we assume all terms explicitly 
attributed by their types at runtime. We employ this property to implement a unification algorithm in regular OCaml, using some
representation for terms and types:

\begin{lstlisting}[mathescape=true]
    val unify : term -> term -> subst option -> subst option
\end{lstlisting}

\noindent where ``\lstinline{term}'' stands for some type, representing typed terms, ``\lstinline{subst}''~--- for the type of 
substitution (a partial mapping from logic variables to terms). Unification can fail (hence ``\lstinline{option}'' in the result type), 
is performed in the context of existing substitution (hence ``\lstinline{subst}'' in the third argument) and can be 
chained (hence ``\lstinline{option}'' in the third argument). 

We use exactly the same unification algorithm with triangular substitution, as in the reference implementation~\cite{MicroKanren}. We
omit here some not-so-important details (like ``occurs check'') and refrain from discussing the nature and properties of the algorithm
itself (an excellent description, including certified correctness proof, can be found in~\cite{Kumar}).

The following snippet presents the implementation:

\begin{lstlisting}[mathescape=true,numbers=left,numberstyle=\small,stepnumber=1,numbersep=-5pt]
    let rec unify $t_1^\tau$ $t_2^\tau$ $subst$ = 
      let rec walk $s$ $t^\tau$ = 
        match $t^\tau$ with
        | $x^\tau$ when $x^\tau\in dom(s)$ -> $\;\;$walk $s$ $(s\;\;x^\tau)$
        | _ -> $t^\tau$
      in
      match $subst$ with
      | None -> None
      | Some $s$ ->
          match walk $s$ $t_1^\tau$, walk $s$ $t_2^\tau$ with
          | $x_1^\tau$, $x_2^\tau$ when $x_1^\tau$ = $x_2^\tau$ -> $subst$
          | $x_1^\tau$, $q_2^\tau$ -> Some ($s\;[x_1^\tau \gets q_2^\tau]$)
          | $q_1^\tau$, $x_2^\tau$ -> Some ($s\;[x_2^\tau \gets q_1^\tau]$)
          | $C^\tau(t_1^{\tau_1},\dots,t_k^{\tau_k})$, $C^\tau(p_1^{\tau_1},\dots,p_k^{\tau_k})$ -> 
              unify $t_k^{\tau_k}$ $p_k^{\tau_k}$(.. (unify $t_1^{\tau_1}$ $p_1^{\tau_1}$ $subst$)$..$)
          | $\_$, $\_$ -> None
\end{lstlisting}

We remind, that all superscripts correspond to type attributes, which we consider here as 
parts of values being manipulated. For example, line 1 means, that we apply \lstinline{unify}
to terms $t_1$ and $t_2$, and expect their types to be equal $\tau$. We assume, that 
at the top level unification always applied to some terms of the same type, and that arbitrary
substitution can only be acquired from the empty one by a sequence of unifications.

We are going to show, that under these assumption all type attributes are superfluous~--- they
do not affect the execution of \lstinline{unify} and can be removed. Note, that the only place, where we
were incapable of providing an explicit type attribute, was in the line 4, where the result of
substitution application was returned. However, we can prove by induction, that any substitution 
respects the following property: if a substitution $s$ is defined for a variable $x^\tau$,
then $s\;\;x^\tau$ is attributed with the type $\tau$ (and, consequently, \lstinline{walk $s$ $t^\tau$} always
returns a term of type $\tau$).

Indeed, this property vacuously holds for empty substitution. Let $s$ be some substitution, for which the
property holds. In the line 11 we return unchanged substitution; in the line 10 we perform two calls~--- 
\lstinline{walk $s$ $t_1^\tau$} and \lstinline{walk $s$ $t_2^\tau$}, and match their results. However, 
by induction hypothesis these results are again attributed by the type $\tau$, which justifies the
pattern matching. In the line 11 we return the substitution unchanged, in lines 12 and 13 we extend the
existing substitution, but preserve the property of interest. Finally, in the line 15 we chain a few
applications of \lstinline{unify}; note, that, again, all these calls are performed for terms of equal 
types, starting from a substitution, posessing the property of interest. A simple induction on the
chain length completes the proof.

\begin{comment}
Type annotations, included in the snippet above, can be justified by the following 
reasonings\footnote{We omit verbal description of unification algorithm; 
the details can be found in~\cite{MicroKanren}.}:

\begin{enumerate}
\item Line 2: the type of \mbox{$(s\;\;x^\tau)$} is $\tau$ due to invariant 2; hence, 
the type of \lstinline{walk} result coincides with the type of its second argument (technically,
an induction on the number of recursive invocations of \lstinline{walk} is needed).

\item Line 9: the substitution is left unchanged, hence all invariants are preserved.

\item Line 10 (and, symmetrically, line 11): first, note, that \mbox{$(s\;\;x_1)$} is undefined
(otherwise \lstinline{walk} would not return $x_1$). Then, $x_1$ and $t_2^\prime$ have the
same type, which justifies the preservation of invariant 2. Finally, either \mbox{$x_1=t_1$}
(and, then, $\tau$ is the type of $x_1$, assigned by the compiler), or $x_1$ is retrieved
from $s$ with type $\tau$~--- both cases justify invariants 1 and 3. The same applies to 
the pair $t_2^\prime$ and $t_2$.

\item The previous paragraph justifies the base case for inductive proof on the number of
recursive invocations of \lstinline{unify}.
\end{enumerate}
\end{comment}

Note, the type of substitution is not polymorphic, which means, 
that the compiler completely loses the track of types for values, stored in a substitution. These types are recovered later 
during the refinement of answers.
Outside unification the compiler maintains typing, which means, that all terms, subterms, and variables agree in their types 
in all contexts. However, as our implementation resorts to unsafe features, we have to manually repeat this work for 
unification code.


%The relevent part of OCaml type system can be reduced to this formulation as follows: in OCaml any value is 
%attributed by a (potentially) polymorphic type at compile-time. Since at runtime there are no polymorphic values, the runtime 
%type of any value is an instantiation of a compile-time type by some runtime-types.

Function \lstinline{unify} is not directly accessible at the user level; it used
to implement both unification (``\lstinline{===}'') and disequality (``\lstinline{=/=}'') 
goals. The implementation generally follows~\cite{CKanren}.


\begin{comment}

We argue, that the following three invariants are maintained for any substitution $s$, involved in the unification:

\begin{enumerate}
\item if \mbox{$t_1^{\_}[x^{\tau}]$} and \mbox{$t_2^{\_}[x^{\rho}]$}~--- two arbitrary terms (in particular, 
$t_1^{\_}$ and $t_2^{\_}$ may be the same), bound in $s$ and containing occurrences of variable $x$, 
then $\rho=\tau$ (different occurrences of the same variable in $s$ are attributed with the same type);

\item if \mbox{$(s\;\;x^\tau)$} is defined, then \mbox{$(s\;\;x^\tau) = t^\tau$} (a substitution always
binds a variable to a term of the same type);

\item each variable in $s$ preserves its type, assigned by the compiler (from the first two invariants 
it follows, that this type is unique; note also, that all variables are created and have their types assigned outside 
unification, in a type-safe world).
\end{enumerate}

The initial (empty) substitution trivially fulfills these invariants; hence, it is sufficient
to show, that they are preserved by unification.
\end{comment}
