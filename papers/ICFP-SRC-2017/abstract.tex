\documentclass[preprint,numbers,10pt]{sigplanconf}

\usepackage{makeidx}
\usepackage{amssymb}
\usepackage{listings}
\usepackage{indentfirst}
\usepackage{verbatim}
\usepackage{amsmath, amssymb}
\usepackage{graphicx}
\usepackage{color}
\usepackage{url}
\usepackage{xspace}
%\usepackage[belowskip=-15pt,aboveskip=0pt]{caption}

\definecolor{light-gray}{gray}{0.90}
\newcommand{\graybox}[1]{\colorbox{light-gray}{\texttt{#1}}}
\newcommand{\miniKanren}{\texttt{miniKanren}\xspace}
\newcommand{\ocanren}{\texttt{OCanren}\xspace}
\newcommand{\ocaml}{\texttt{OCaml}\xspace}

\lstdefinelanguage{ocaml}{
keywords={let, begin, end, in, match, type, and, fun, 
function, try, with, class, object, method, of, rec, repeat, until,
while, not, do, done, as, val, inherit, module, sig, @type, struct, 
if, then, else, open, virtual, new, fresh},
sensitive=true,
basicstyle=\small,
commentstyle=\scriptsize\rmfamily,
keywordstyle=\ttfamily\bfseries,
identifierstyle=\ttfamily,
basewidth={0.5em,0.5em},
columns=fixed,
fontadjust=true,
literate={fun}{{$\lambda$}}1 {->}{{$\to$}}3 {===}{{$\equiv$}}1 {=/=}{{$\not\equiv$}}1 {|>}{{$\triangleright$}}3 {\&\&\&}{{$\wedge$}}2 {|||}{{$\vee$}}2 {^}{{$\uparrow$}}1,
morecomment=[s]{(*}{*)}
}

\lstset{
mathescape=true,
basicstyle=\small,
identifierstyle=\ttfamily,
keywordstyle=\bfseries,
commentstyle=\scriptsize\rmfamily,
basewidth={0.5em,0.5em},
fontadjust=true,
escapechar=!,
language=ocaml
}

\sloppy
\newcommand{\cc}{\mbox{ :: }}
\newcommand{\opt}[1]{\mbox{[ }#1\mbox{ ] }}
\newcommand{\etc}{\mbox{ }\ldots}
\newcommand{\term}[1]{\mbox{\texttt{#1}}}
\newcommand{\nt}[1]{$#1$}
\newcommand{\meta}[1]{\textsc{#1}}
\newcommand{\spc}{\mbox{ }}
\newcommand{\alt}{\mbox{ | }}
\newcommand{\trans}[3]{{#1}\vdash{#2}\to{#3}}
\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\kw}[1]{\texttt{\textbf{#1}}}
\newcommand{\comm}[1]{\textit{\small{#1}}}
\newcommand{\tv}[1]{\mbox{$'{#1}$}}
\newcommand{\inmath}[1]{\mbox{\lstinline{#1}}}
\newcommand{\goal}{\mathfrak G}

\begin{document}

%\mainmatter

\title{Improving Refutational Completeness of Relational Specifications\\
via Non-Termination Test\\
{\small (Extended Abstract)}}

\authorinfo{Dmitri Rozplokhas}
{St. Petersburg Academic University, St. Petersburg, Russia}
{rozplokhas@gmail.com\\
Postal address: Khlopina st., 8 bldg. 3, lit. A, 194021, St. Petersburg, Russia\\
Scientific advisor: Dmitri Boulytchev\\
ACM student member number: 9150868\\
Category: undergraduate
}

%\author{}
%\institute{St. Petersburg State University, St. Petersburg, Russia\\
%\email{lozov.peter@gmail.com}\\
%Postal address: 70/3, Botanicheskaya street, 198504, St. Petersburg, Russia\\
%Scientific advisor: Dmitri Boulytchev\\
%ACM student member number: 4970108\\
%Category: graduate}

\maketitle

%\begin{multicols}{2}
\section{Introduction}

Relational programming is a technique, based on describing programs not as functions, but 
as relations, without distinguishing between the arguments and the result values. This technique makes it 
possible to ``query'' programs in various ways, for example, execute them ``backwards'', finding
all sets of arguments for a given result. This behavior can be simulated using a number of
logic programming languages, such as Prolog, Mercury\footnote{\url{https://mercurylang.org}}, 
or Curry\footnote{\url{http://www-ps.informatik.uni-kiel.de/currywiki}}. 
There is also a family of embedded DSLs, specifically designed for writing declarative relational
programs, which originates from the language, called \miniKanren~\cite{TRS}. \miniKanren is a minimalistic 
declarative language initially developed for Scheme/Racket. The smallest implementation of \miniKanren 
is reported to comprise of only 40 LOC~\cite{MicroKanren, 2016}; there are also more elaborate versions, including
\miniKanren with constaints~\cite{CKanren, CKanren1}, user-assisted search~\cite{Guided}, nominal unification~\cite{AlphaKanren},
etc. Due to its simplicity \miniKanren was implemented for more than 50 other languages, such as
Haskell, Go, Smalltalk, and OCaml.

\miniKanren has proven to be a useful tool to elegantly solve various problems, otherwise considered as non-trivial~\cite{WillThesis};
one of the main applications of \miniKanren for now lies is the area of \emph{relational interpreters}~--- the interpreters, which (for a given language)
are capable of providing programs, delivering specified results~\cite{Untagged}.

Despite being quite simple and easy to use by the design, in implementation \miniKanren introduces some subtleties. Under the hood, \miniKanren 
uses complete interleaving search~\cite{Search}. This search is guaranteed to find all existing solutions; however, it can diverge, when no 
solution exists. In reality this amounts to a divergence in a number of important cases~--- for example, when the program is asked to 
return \emph{all} existing solutions, or when the number of requested solutions exceeds the number of existing ones. Often, for a 
concrete query it is possible to refactor the specification to avoid the divergence, but this means, that the specification has to be adjusted for every 
execution ``direction'' of interest, which to some extent compromises the idea of fully declarative relational programming. 

The specifications, which do not diverge even when no solutions exist, are called \emph{refutationally complete}~\cite{WillThesis}. Writing 
refutationally complete relational specifications nowadays requires the knowledge of \miniKanren implementation intrinsics, and not always
possible by the undecidability of the fundamental computability problems. However, by developing a more advanced search it is possible
to make more specifications refutationally complete.

In this work we present an optimization technique, which is based on a certain non-termination test. Our optimization is \emph{online} (performed during the
search), \emph{non-intrusive} (does not introduce new constructs or require any changes in existing specifications), and \emph{conservative} 
(applied only when the divergence is detected). We prove, that for queries, which return a finite number of answers, our optimization is non-degrading. 
We also demonstrate the application of the optimization for a number of interesting and important problems.



\begin{comment}
\section{Background and Related Works}

The problem of converting functional programs into relational form was addressed in preceding works on 
miniKanren~\cite{TRS,WillThesis}. According to the approach, proposed there, an $n$-argument function 
is converted into $n+1$ relation, where the $n+1$-th argument corresponds to the former 
function's result. This technique, however, can deal only with first-order programs. 

We argue, that in high-order case the conversion can not be performed for untyped terms, 
and develop an approach for typed case.

\section{Approach and Current Results}

Our approach is pretty much type-driven. We start from simply typed case (STLC~\cite{Barendregt} 
plus data constructors, pattern matching and primitive types) and enrich it with relational 
constructs and typing rules for them. 

Then we present a type conversion function $\left[\bullet\right]$, which for each type provides 
its relational counterpart. For example,

$$
\begin{array}{rcl}
\left[\inmath{int}\right]                   & = & \inmath{int} \to \goal \\
\left[\inmath{string}\to\inmath{int}\right] & = & (\inmath{string} \to \goal) \to (\inmath{int} \to \goal)
\end{array}
$$

\noindent where $\goal$ (\emph{goal type}) stands for the unique type for closed purely relational expressions. In other words,
we convert primitive values into unary relations and functions into high-order relations.

We present then structural conversion rules for terms, which project them into the purely relational
subset, and prove, that for a typed source program we always get a typed relational specification, thus
justifying the static soundness. There is some difficulty in justifying dynamic correctness, however, as
miniKanren currently does not have formally described semantics. We argue, that our approach provides 
extension for known first-order case, and demonstrate its feasibility in high-order case by the number
of examples, this justifying the correctness in an \emph{ad hoc} manner.

\section{Ongoing and Future Work}

We are working now on the extension of our approach for polymorphic case; it seems, that now not 
every program can be given a relational counterpart, so the first step is to restrict the type system to
type only the ``useful'' subset. After completing the ``pen-and-paper'' work we are going to implement the
convertor and apply it to obtain some useful relational specifications (the primary goals are, of course, 
some interpreters and miniKanren with constraints~\cite{CKanren}). Verifying the proofs in a proof assistant 
like Coq is also considered as an option.

Another direction of the research would be to develop a native type systems for relational programming.
\end{comment}

\begin{thebibliography}{99}
\bibitem{TRS}
Daniel P. Friedman, William E.Byrd, Oleg Kiselyov. The Reasoned Schemer. The MIT
Press, 2005.

\bibitem{MicroKanren}
Jason Hemann, Daniel P. Friedman. $\mu$Kanren: A Minimal Core for Relational Programming //
Proceedings of the 2013 Workshop on Scheme and Functional Programming (Scheme '13).

\bibitem{Guided}
Cameron Swords, Daniel P. Friedman. rKanren: Guided Search in miniKanren //
Proceedings of the 2013 Workshop on Scheme and Functional Programming (Scheme '13). 

\bibitem{AlphaKanren}
William E. Byrd, Daniel P. Friedman. alphaKanren: A Fresh Name in Nominal Logic Programming //
Proceedings of the 2007 Workshop on Scheme and Functional Programming (Scheme '07).

\bibitem{2016}
Jason Hemann, Daniel P. Friedman, William E. Byrd, Matthew Might.
A Small Embedding of Logic Programming with a Simple Complete Search //
Proceedings of the 12th Symposium on Dynamic Languages (DLS 2016).

\bibitem{Untagged}
William E. Byrd, Eric Holk, Daniel P. Friedman.
miniKanren, Live and Untagged: Quine Generation via Relational Interpreters (Programming Pearl) //
Proceedings of the 2012 Workshop on Scheme and Functional Programming (Scheme '12).

\bibitem{CKanren}
Claire E. Alvis, Jeremiah J. Willcock, Kyle M. Carter, William E. Byrd, Daniel P. Friedman.
cKanren: miniKanren with Constraints // 
Proceedings of the 2011 Workshop on Scheme and Functional Programming (Scheme '11).

\bibitem{CKanren1}
Jason Hemann, Daniel P. Friedman. A Framework for Extending microKanren with Constraints //
Proceedings of the 2015 Workshop on Scheme and Functional Programming (Scheme '15).

\bibitem{WillThesis}
William E. Byrd. Relational Programming in miniKanren: Techniques, Applications, and Implementations.
Indiana University, Bloomington, IN, September 30, 2009.

%\bibitem{Barendregt}
%Henk Barendregt. Lambda Calculi with Types // Handbook of Logic in Computer Science, Volume II, Oxford University Press, 
%1993.

\bibitem{Search}
Oleg Kiselyov, Chung-chieh Shan, Daniel P. Friedman, Amr Sabry. Backtracking, Interleaving, and Terminating Monad Transformers (functional pearl) //
Proceedings of the 10th ACM SIGPLAN International Conference on Functional Programming (ICFP '05).

\bibitem{Ocanren}
Dmitry Kosarev, Dmitry Boulytchev. Typed Embedding of a Relational Language in OCaml // ACM SIGPLAN Workshop on ML, 2016.

\bibitem{PE}
Neil D. Jones, Carsten K. Gomard, Peter Sestoft. Partial Evaluation and Automatic Program Generation. Prentice-Hall, 1993.

\end{thebibliography}
%\end{multicols}
\end{document}
