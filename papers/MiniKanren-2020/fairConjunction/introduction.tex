\section{Introduction}

Declarative programming is a programming paradigm, which allows to express the logic of a computation without describing its control flow. One of the declarative languages is relational language \mk~\cite{fair:TheReasonedSchemer}. This minimalistic language has only few operators. This minimalistic language consists of only a few operators, and its minimal implementation~\cite{fair:micro} contains only 54 code lines of Racket. Despite its modest size, \mk is Turing complete and allows to express complex computations in the form of compact declarative specifications. For instance, quine generator~\cite{fair:quines}, proof checker and theorem prover~\cite{fair:teorem-prover}, interpreter to perform example-based program synthesis~\cite{fair:seven} has declarative solution of \mk.

However, \textit{conjunction}, one of \mk operators, has imperative behaviour. The evaluation of the conjuncts is asymmetric and the order of the conjuncts affects not only the efficient of the program, but even the convergence. As a result, the developer sets the control flow when choosing the order of the conjuncts. This directed behaviour of conjunction we call \textit{unfair}.

% Проблема несправедливого поведения конъюнкции уже рассматривалась с нескольких разных точек зрения. Одним из аспектов несправедливого поведения конъюнкции является управления приоритетами вычисления независимых ветвей, которые порождает конъюнкция. В оригинальном языке больший приоритет отдается более ранней ветке. Однако существует подход, который позволяет сбалансировать время исполнения. Это делает поведение конъюнкции более справедливым, но чувствительность к порядку конъюнктов сохраняется. Также конъюнкция становится более честной, если детектировать расхождение конъюнктов. Данный подход во время исполнения может обнаружить расхождение конъюкта. В этом случае данные, которые были получены при исполнении конъюнкта стираются. После чего происходит перестановка конъюнктов и продолжается исполнение программы. Данный подход оказывается эффективен на практике. Недостатком является консервативная перестановка конъюнктов, которпя не использует информацию, полученную при вычислении конъюнкта до перестановки.
The problem of unfair behavior of conjunction has already been examined from several different points of view. One aspect of the unfair behavior of a conjunction is to prioritize the evaluation of the independent branches that the conjunction generates. In the original \mk, a higher priority is given to an earlier branch. However, there is an approach~\cite{fair:towardsAM} that allows you to balance the time of the evaluation. This makes the conjunction behavior more fair, but order of the conjuncts still affects both efficiency and convergence. Also, the conjunction becomes more fair we will detect divergence of conjuncts. This approach~\cite{fair:DivTest} at run time can detect conjunct divergence. In this case, the data that was received during the evaluation of the conjunct is erased. After that there is a rearrangement of the conjuncts and the evaluation of the program continues. This approach is effective in practice. However, the conservative rearrangement of the conjuncts does not use the information obtained when evaluating the conjunct before the rearrangement. There are also examples for this approach where the order of the conjuncts affects convergence.

The contribution of this paper is a more declarative approach to the evaluation of relational programs of \mk. This approach executes the conjuncts alternately, choosing a more optimal execution order. The fair conjunction that we propose is comparable in efficiency to the classic unfair one, but the order of the conjunct weakly affects both efficiency and convergence. Our approach also has higher convergence, because there are examples where the classical conjunction diverges for any order of conjunctions, and the fair conjunction converges.

The paper organized as follows. In section 2, we discuss the advantages and drawbacks of the classic directional conjunction. Section 3 contains a description of the \mk syntax, as well as operational semantics based on the Unfolding operation. In section 4, we present the semantics of a naive fair conjunction, and in section 5 we expand this semantics by controlling the conjunction order based on structural recursion. Section 6 is devoted to testing and comparing effectiveness in practice. The final section concludes.
