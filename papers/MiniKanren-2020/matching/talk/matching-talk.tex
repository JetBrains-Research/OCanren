\def\pgfsysdriver{pgfsys-dvipdfm.def} % required for tress inside
\documentclass[aspectratio=169
  , xcolor={svgnames}
  , hyperref={ colorlinks,citecolor=Blue
             , linkcolor=DarkRed,urlcolor=DarkBlue}
  , russian
  ]{beamer}
\usetheme{CambridgeUS}
\usefonttheme{professionalfonts}

% get rid of header navigation bar
\setbeamertemplate{headline}{}
% get rid of bottom navigation symbols
\setbeamertemplate{navigation symbols}{}

\usepackage{pgfpages}
%\setbeamertemplate{note page}[plain]
%\setbeameroption{show notes on second screen=right}

\usepackage{bibentry}
\usepackage{cite}
%\usepackage{natbib}
\def\newblock{\hskip .11em plus .33em minus .07em}
% get rid of footer
%\setbeamertemplate{footline}{}

\input{heading.tex}

\usepackage{subcaption}
\usepackage{etoolbox}


\usepackage{exercise}
\usepackage{tikz}
 \usepackage{tikz-qtree}
\usetikzlibrary{trees}
\usepackage[edges]{forest}
\forestset{.style={
%  for tree={l=1em, l sep=1em, s sep=1em}
  forked edges,
    for tree={    grow'=0,    draw,    align=c,    font=\sffamily,
        rounded corners  }
  }}

\newcommand{\lstquot}[1]{``\lstinline{#1}''}
\newcommand{\sembr}[1]{\llbracket{#1}\rrbracket}
\newcommand\false{$f\!alse$}
\newcommand\myif{i\!f}


\def\transarrow{\xrightarrow}
\newcommand{\setarrow}[1]{\def\transarrow{#1}}

\def\padding{\phantom{X}}
\newcommand{\setpadding}[1]{\def\padding{#1}}

\def\subarrow{}
\newcommand{\setsubarrow}[1]{\def\subarrow{#1}}

\newcommand{\trule}[2]{\dfrac{#1}{#2}}
\newcommand{\crule}[3]{\dfrac{#1}{#2},\;{#3}}
\newcommand{\withenv}[2]{{#1}\vdash{#2}}
\newcommand{\trans}[3]{{#1}\transarrow{\padding{\textstyle #2}\padding}\subarrow{#3}}
\newcommand{\ctrans}[4]{{#1}\transarrow{\padding#2\padding}\subarrow{#3},\;{#4}}
\newcommand{\llang}[1]{\mbox{\lstinline[mathescape]|#1|}}
\newcommand{\pair}[2]{\inbr{{#1}\mid{#2}}}
\newcommand{\inbr}[1]{\left<{#1}\right>}
\newcommand{\highlight}[1]{\color{red}{#1}}
%\newcommand{\ruleno}[1]{\eqno[\scriptsize\textsc{#1}]}
\newcommand{\ruleno}[1]{\mbox{[\textsc{#1}]}}
\newcommand{\rulename}[1]{\textsc{#1}}
\newcommand{\inmath}[1]{\mbox{$#1$}}
\newcommand{\lfp}[1]{fix_{#1}}
\newcommand{\gfp}[1]{Fix_{#1}}
\newcommand{\vsep}{\vspace{-2mm}}
\newcommand{\supp}[1]{\scriptsize{#1}}
\renewcommand{\sembr}[1]{\llbracket{#1}\rrbracket}
\newcommand{\cd}[1]{\texttt{#1}}
\newcommand{\free}[1]{\boxed{#1}}
\newcommand{\binds}{\;\mapsto\;}
\newcommand{\dbi}[1]{\mbox{\bf{#1}}}
\newcommand{\sv}[1]{\mbox{\textbf{#1}}}
\newcommand{\bnd}[2]{{#1}\mkern-9mu\binds\mkern-9mu{#2}}
\newcommand{\meta}[1]{{\mathcal{#1}}}
\newcommand{\dom}[1]{\mathtt{dom}\;{#1}}
%\newcommand{\primi}[2]{\mathbf{#1}\;{#2}}
\renewcommand{\dom}[1]{\mathcal{D}om\,({#1})}
\newcommand{\ran}[1]{\mathcal{VR}an\,({#1})}
\newcommand{\fv}[1]{\mathcal{FV}\,({#1})}
\newcommand{\tr}[1]{\mathcal{T}r_{#1}}
\newcommand{\diseq}{\not\equiv}
\newcommand{\reprfunset}{\mathcal{R}}
\newcommand{\reprfun}{\mathfrak{f}}
\newcommand{\cstore}{\Omega}
\newcommand{\cstoreinit}{\cstore_\epsilon^{init}}
\newcommand{\csadd}[3]{add(#1, #2 \diseq #3)}  %{#1 + [#2 \diseq #3]}
\newcommand{\csupdate}[2]{update(#1, #2)}  %{#1 \cdot #2}
\newcommand{\primi}[1]{\mathbf{#1}}
\newcommand{\sem}[1]{\llbracket #1 \rrbracket}
\newcommand{\ir}{\ensuremath{\mathcal{S}}}
\usepackage{tikz}
\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
    \node[shape=circle,draw,inner sep=1pt] (char) {#1};}}

\let\emptyset\varnothing
\let\eps\varepsilon

% for fancy table
\newcommand{\lheadl}[2]{\multicolumn{1}{|>{\centering\arraybackslash}m{#1}|}{{#2}}}
\newcommand{\head}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}}{\textbf{\small #2}}}
\newcommand{\headll}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}||}{\textbf{\small #2}}}
\newcommand{\lheadll}[2]{\multicolumn{1}{|>{\centering\arraybackslash}m{#1}||}{\textbf{\small #2}}}
\newcommand{\headl}[2]{\multicolumn{1}{>{\centering\arraybackslash}m{#1}|}{\textbf{\small #2}}}
\usepackage{longtable}
\newcommand{\nodata}{}
\newcommand{\tablenotemark}[1]{#1}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\title{Relational Synthesis for Pattern Matching}

\date{miniKanren Workshop, August 2020}


\newcommand{\verbatimfont}[1]{\def\verbatim@font{#1}}
\usepackage{verbatimbox}


\begin{document}
\maketitle

% For every picture that defines or uses external nodes, you'll have to
% apply the 'remember picture' style. To avoid some typing, we'll apply
% the style to all pictures.
\tikzstyle{every picture}+=[remember picture] 

% By default all math in TikZ nodes are set in inline mode. Change this to
% displaystyle so that we don't get small fractions.
\everymath{\displaystyle}
%\begin{comment}
% Uncomment these lines for an automatically generated outline.
\begin{frame}{Pattern Matching}
Effective compilation of pattern matching is essential for functional programming
\vspace{1cm}

Two main approaches to compile:
\begin{itemize}
\item decision diagrams
\begin{itemize}
\item guaranteed amount of checks performed (speed)
\end{itemize}
\item backtracking automaton
\begin{itemize}
\item guaranteed code size
\end{itemize}\pause
\item \textbf{synthesis} (our approach)
\end{itemize}
  \note{}
%  \note[enumerate]
%  {
%  \item Stress this first.
%  \item Then this.
%  }
  
\end{frame}


\begin{frame}[fragile]{An Example of Pattern Matching and It's Two Compiled Representations}
\begin{figure}[ht]
\begin{subfigure}[b]{0.25\linewidth}
%\centering
\begin{lstlisting}
match x,y,z with
| _,F,T -> 1
| F,T,_ -> 2
| _,_,F -> 3
| _,_,T -> 4
\end{lstlisting}
\caption{Pattern matching}
\end{subfigure}
\hspace{0.5cm}
\begin{subfigure}[b]{0.32\linewidth}
%\centering
\begin{lstlisting}
if x then
  if y then
    if z then 4 else 3
  else
    if z then 1 else 3
else
  if y then 2
  else
    if z then 1 else 3
\end{lstlisting}
\caption{Correct but semi-optimal compilation}
\label{fig:matching-example2}
\end{subfigure}
\hspace{0.5cm}
\begin{subfigure}[b]{0.3\linewidth}
\centering
\begin{lstlisting}
if y then
  if x then
    if z then 4 else 3
  else 2
else
  if z then 1 else 3
\end{lstlisting}
\caption{Optimal compilation}
\label{fig:matching-example3}
\end{subfigure}
\caption{Pattern matching compilation can be non-trivial (example from~\cite{maranget2008}).}
\label{fig:match-example}
\end{figure}
 \note{This is an example from Luc Maranget's paper.
 
 Pattern matchin is on the left. We can start testing from $x$, and then $y$ and $z$, it will give us a program with 6 $if$ constructions. But we can start testing from $y$ and if it is $false$ we can not test $x$. It will give us a program with four tests.}
\end{frame}

\begin{frame}{Our Method: Synthesis + Relational Interpreter}
Do \emph{not compile} with specific algorithm but \emph{synthesize} compiled representation on large enough but finite set of examples
\vspace{1cm}

Minimization criteria: less checks written in synthesized program.
\vspace{1cm}

We are going to use relational programming, more precisely OCanren~\cite{OCanrenWeb} from miniKanren~\cite{MiniKanrenWeb} family.
\vspace{1cm}


Our repo on Github: ~\cite{Repo}.
\end{frame}


\begin{frame}[fragile]{Pattern Matching Syntax}
\begin{figure}[ht]
\begin{subfigure}[b]{0.3\linewidth}
\[
 \begin{array}{rcll}
    \mathcal{C} & = & \{ C_1^{k_1}, \dots, C_n^{k_n} \}\\
    \mathcal{V} & = & \mathcal{C}\,\mathcal{V}^*\\  
    \mathcal{P} & = & \_ \mid \mathcal{C}\,\mathcal{P}^*
 \end{array}
\]
\end{subfigure}
\hspace{0.5cm}
\begin{subfigure}[b]{0.5\linewidth}
\[
\begin{array}{rcl}
  \mathcal M & = & \bullet \\
  &   & \mathcal M\,[\mathbb{N}] \\
  \ir & = & \primi{return}\,\mathbb{N} \\
  &   & \primi{switch}\;\mathcal{M}\;\primi{with}\; [\mathcal{C}\; \primi{\rightarrow}\; \ir]^*\;\primi{otherwise}\;\ir
\end{array}
\]
\end{subfigure}
\end{figure}
\vspace{0.5cm}
Things that are omitted for simplicity: guards, pattern variables

TODO: program size here?
\end{frame}

\begin{frame}[fragile]{Example 1 (1/2)}
\begin{figure}
\begin{subfigure}[b]{0.3\linewidth}
\begin{forest}
  forked edges,
  for tree={    grow'=0,    draw,    align=c,    font=\sffamily,
      rounded corners  },
  highlight/.style={    thick,    font=\sffamily\bfseries  }
    [{pats}
      [{Cons}
      [{Cons}
            [{\_}]
            [{\_}]
      ]
      [{\_}]
      ]
      [{\_}]
    ]
\end{forest}
\end{subfigure}
\hspace{3.5cm}
\begin{subfigure}[b]{0.4\linewidth}
\begin{lstlisting}{ocaml}
match (s : unit list) with 
| _ :: _ :: _ -> 1
| _           -> 2
\end{lstlisting}
\vspace{1cm}
\begin{itemize}
\item Pattern matching (above)
\item with two branches
\end{itemize}
\end{subfigure}
\end{figure}

\end{frame}

\begin{frame}[fragile]{Example 1 (2/2)}
\begin{figure}
\begin{subfigure}[b]{0.3\linewidth}
\begin{forest}
  forked edges,
  for tree={    grow'=0,    draw,    align=c,    font=\sffamily,
      rounded corners  },
  highlight/.style={    thick,    font=\sffamily\bfseries  }
    [{3 \\ examples}
    [{Cons}
      [{Unit}]
      [{Cons}
            [{Unit}]
            [{Nil}]
      ]      
    ]
    [{Cons} [{Unit}]  [{Nil}]]
    [{Nil}]
    ]
\end{forest}
\end{subfigure}
\hspace{4.5cm}
\begin{subfigure}[b]{0.35\linewidth}
\begin{lstlisting}{ocaml}
match (s : unit list) with 
| _ :: _ :: _ -> 1
| _           -> 2
\end{lstlisting}
\vspace{1cm}
\begin{itemize}
\item Pattern matching (above)
\item height = 3
\item with examples bounded by the height of patterns 
\end{itemize}
\end{subfigure}
\end{figure}
\end{frame}


\begin{frame}[fragile]{Example 2 (1/2) }
\begin{figure}
\begin{subfigure}[b]{0.3\linewidth}
\begin{forest}
  forked edges,
  for tree={    grow'=0,    draw,    align=c,    font=\sffamily,
      rounded corners  },
  highlight/.style={    thick,    font=\sffamily\bfseries  }
    [{pats}
      [{Nil}]
      [{\_}]
    ]
\end{forest}
\end{subfigure}
\hspace{.5cm}
\begin{subfigure}[b]{0.6\linewidth}
%\texttt{hello [] 111}
\begin{lstlisting}[language=ocaml]
match (s : unit list) with 
| []  -> 1
| _   -> 2
\end{lstlisting}
\vspace{1cm}
\begin{itemize}
\item All inhabitants bound by height = 1 -- is a set of single element
\item It is not enough
\item We should test at least on an expression that starts from Cons  (\lstinline{unit :: []}, for instance)
\item but if we don't do that...
\end{itemize}
\end{subfigure}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Example 2 (2/2) }
\begin{figure}
\begin{subfigure}[b]{0.3\linewidth}
\begin{forest}
  forked edges,
  for tree={    grow'=0,    draw,    align=c,    font=\sffamily,
      rounded corners  },
  highlight/.style={    thick,    font=\sffamily\bfseries  }
    [{pats}
      [{Nil}]
      [{\_}]
    ]
\end{forest}
\vspace{1cm}

Wrong set of examples:
\begin{itemize}
\item \verb=Nil=
\end{itemize}
\vspace{1cm}
\end{subfigure}
\hspace{.5cm}
\begin{subfigure}[b]{0.6\linewidth}
\begin{lstlisting}{ocaml}
match (s : unit list) with 
| []  -> 1
| _   -> 2
\end{lstlisting}
\vspace{1cm}
\begin{itemize}
\item ... and test single example \verb=[]= (i.e. Nil)
\item then the synthesized program 
\[
 \begin{array}{ll}
    \primi{switch} \dots \primi{with}   & \\
    |\ \text{Nil} \rightarrow 1  & \\  
    |\ \primi{otherwise} \rightarrow  1 & 
 \end{array}
\]
behaves the same on our set of examples
\item but obviously wrong
\end{itemize}
\end{subfigure}
\end{figure}
\end{frame}

\begin{frame}{Current Algorithm for Examples Generation}
\begin{figure}
\begin{subfigure}[b]{0.45\linewidth}
Algorithm briefly:
\begin{itemize}
\item Evaluate height of patterns $h$
\item Synthesize all inhabitants, but
\item on depth $h+1$ use single predefined per type inhabitant 
\end{itemize}
\end{subfigure}
\hspace{.5cm}
\begin{subfigure}[b]{0.45\linewidth}
Pros and cons:
\begin{itemize}
\item[\texttt{+}] It is correct
\item[\texttt{-}] Exponential by height number of patterns required
\end{itemize}
%\vspace{1cm}
%We are currently working on
%\begin{itemize}
%\item When we can generate less examples?
%\item Overall synthesis speed
%\begin{itemize}
%\item it not only depend on a number of examples
%\end{itemize}
%\end{itemize}
\end{subfigure}
\end{figure}

\end{frame}


\begin{frame}{Synthesis Algorithm, More Formally }
High-level description:
\[
depth^o\,v\,n \;\; \wedge \;\;
\mbox{\lstinline|fresh ($i$)|}\; \{match^o\,v\,\,p_1,\dots,p_k\,\,i \;\;\wedge \;
eval^o_{\mathcal S}\,v\,\circled{?}\,i\}
\]

\begin{itemize}
\item $depth^o\,v\,n$ generates examples bound by depth $n$
\item $match^o\,v\,\,p_1,\dots,p_k\,\,i$ resolves branch $i$ for concrete example $v$
\item $\circled{?}$ is a program to be synthesized
\item $eval^o_{\mathcal S}\,v\,\circled{?}\,i$ ensures that synthesized $\circled{?}$ on example $v$ resolves to right branch $i$
\end{itemize}


\end{frame}

\begin{frame}{Improvement: Cutting bad branches}

Our answer is always in single variable -- $\circled{?}$ and during the search we \emph{only} extend it with new switch branches\\

\begin{alertblock}{Idea}
If current estimate is longer than shortest answer already found -- cut this branch
\end{alertblock}

Is implemented as new primitive called \emph{structural constraint}:
\begin{itemize}
\item Takes a logic value and performs reification in current state
\item Takes a predicate which investigates reified value 
\item If there are too many branches in it then stop the search ($failure^o$)
\item Otherwise: continue search without changing state ($success^o$)
\end{itemize}

\end{frame}


\begin{frame}[fragile]{Improvement: Reducing Examples Set}
An example:
\begin{lstlisting}{ocaml}
match (s : bool * bool * bool) with 
| (_,_,F) -> 0
| (_,_,T) -> 1
\end{lstlisting}
\vspace{.5cm}
We can statically decide that 

\begin{itemize}
\item There are $2^3$ inhabitants of type \lstinline=bool * bool * bool=.
\item No need to  check that scrutinee is a triple
\item No need to look at 1st and 2nd subtrees of triple (only 3rd matters)
\end{itemize}
\vspace{.5cm}

So, we can run synthesis only on two examples $\{(\mathcal{B},\mathcal{B},\text{T}),(\mathcal{B},\mathcal{B},\text{F})\}$
where $\mathcal{B}$ is any value of type \lstinline=bool=.
%$\text{T}\!\!\! \text{F}$
\end{frame}


%\end{comment}

\begin{frame}[fragile,allowframebreaks]{Experiments}
%\begin{table}[H]
  \begin{longtable}{|m{3.5cm}||cccccc|}
\hline
    \lheadll{3cm}{Patterns} & 
%    \head{1.5cm}{Size constraint} & 
%    \headll{1.7cm}{Answers requested} & 
    \head{1.5cm}{\scriptsize \# samples} & 
    \head{1.5cm}{\scriptsize 1st answer size} & 
    \head{1.5cm}{\scriptsize 1st answer time (ms)} & 
    \head{1.5cm}{\scriptsize Answers found} & 
    \head{1.5cm}{\scriptsize Last answer size} & 
    \headl{1.5cm}{\scriptsize Total search time (ms)}
\endhead
    \hline
    \hline
\begin{comment}
    \texttt{
A
B
C }&3&&1&2&&2\\ \hline

    \begin{lstlisting}[basicstyle=\scriptsize]
true
false
    \end{lstlisting} &2&&$<$1&1&&$<$1\\
        \hline
\end{comment}
            \begin{lstlisting}[basicstyle=\scriptsize,belowskip=-1.5em,aboveskip=-1em]
(true, _) 
(_, true)
(false, false)
\end{lstlisting}  &4&2&5&1&2&6\\
        \hline
     \begin{lstlisting}[basicstyle=\scriptsize,belowskip=-1.5em,aboveskip=-1em]
(_, false, true)
(false, true, _)
(_, _, false) 
(_, _, true)
\end{lstlisting}   &8&6&$\sim$1000&3&4&$\sim$2000\\
        \hline
%        5&
%     \begin{lstlisting}[basicstyle=\scriptsize]
%([], _)
%(_, [])
%(_ :: _, _ :: _)
%    \end{lstlisting} &100&10&4&5&1&6\\
%        \hline
%        6&
     \begin{lstlisting}[basicstyle=\scriptsize,belowskip=-1.5em,aboveskip=-1em]
type nat = Z 
         | S of nat
  
(Succ _, Succ _)
(Zero, _)
(_, Zero)    \end{lstlisting} &4&2&30&1&2&30
    \\
        \hline
     \begin{lstlisting}[basicstyle=\scriptsize,belowskip=-1.5em,aboveskip=-1em]
type 'a list = 
| Nil 
| Nil2 
| Cons of 'a * 'a list     

(Nil, _)
(_, Nil)
(Nil2, _)
(_, Nil2)
(Cons(_,_),Cons(_,_))
    \end{lstlisting}
     &9&5&24&3& 5  &157                    \\ 
      \hline
%      \hline
     \begin{lstlisting}[basicstyle=\scriptsize,belowskip=-1.5em,aboveskip=-1em]
type code = 
| Push 
|Ldi of int 
| IOp of int 
| Int of int 
type prog = code list 
type item = 
| Val of code 
| Env of int 
| Code of int
type stack = item list 

match (code, stack,prog) 
(_, _, (Ldi _)::_)
(_, _, (Push _)::_)
    \end{lstlisting} &5&3&11&1&3&30\\
        \hline      
        \newpage
        \begin{lstlisting}[basicstyle=\scriptsize,belowskip=-1.5em,aboveskip=-1em]
(_, _, (Ldi _)::_)
(_, _, (Push _)::_)
(Int(_), _, (IOp _)::_)
\end{lstlisting}
     &20&7&$\sim$1700&3&5&$\sim$11000                    \\ \hline
  \end{longtable}

\end{frame}

\begin{frame}[fragile]{Bad Example from PCF Interpreter (1/?)}
\begin{figure}
\begin{subfigure}[b]{0.6\linewidth}
\begin{lstlisting}[basicstyle=\small]
let rec run a s c =
  match a,s,c with
  | (_,_,Ldi i::_) -> 1
  | (_,_,Push::_)  -> 2
  | (Int _,Val (Int _)::_,IOp _::_) -> 3
  | (Int _,_,Test (_,_)::c) -> 4
  | (Int _,_,Test (_,_)::c) -> 5
  | (_,_,Extend::_) -> 6
  | (_,_,Search _::_) -> 7
  | (_,_,Pushenv::_) -> 8
  | (_,Env e::s,Popenv::_) -> 9
  | (_,_,Mkclos cc::_) -> 10
  | (_,_,Mkclosrec _::_) -> 11
  | (Clo (_,_), Val _::_, Apply::_) -> 12
  | (_,(Code _::Env _::_),[]) -> 13
  | (_,[],[]) -> 14
\end{lstlisting}
\end{subfigure}
\hspace{.5cm}
\begin{subfigure}[b]{0.3\linewidth}
Doesn't currently work because types are too large (11102 examples being generated).\\

But for reduced example we can synthesize the answer
\vspace{1cm}
\end{subfigure}
\end{figure}
\end{frame}

\begin{frame}[fragile]{Bad Example from PCF Interpreter (2/?)}
\begin{figure}
\begin{subfigure}[b]{0.45\linewidth}
\begin{lstlisting}[basicstyle=\small]
type code = 
| Push 
| Ldi of int 
| IOp of int 
| Int of int 
type prog = code list 
type item = 
| Val of code 
| Env of int 
| Code of int
type stack = item list 

match (code, stack,prog) with
| (_, _, (Ldi _)::_) -> 1
| (_, _, (Push _)::_) -> 2
\end{lstlisting}
\begin{onlyenv}<2->
\begin{lstlisting}[basicstyle=\small,aboveskip=-0.5em]
| (Int _, _, (IOp _)::_) -> 3
\end{lstlisting}
\end{onlyenv}
\end{subfigure}
\hspace{.5cm}
\begin{subfigure}[b]{0.45\linewidth}
\begin{overlayarea}{7cm}{6cm}
Example is reduces by 
\begin{itemize}
\item types 
\item clauses
\end{itemize}
For two clauses we require 5 examples 
\vspace{1cm}

\begin{onlyenv}<2->
For three clauses and same types we require 20 examples
\begin{itemize}
\item in 1,5s it gives first answer of size 7
\item in next half a second it gives 2nd and 3rd(last) answers of size 6 and 5
\item in the end it 10s proves that no shorter answers exist
\end{itemize}
%\begin{lstlisting}[basicstyle=\small,aboveskip=-0.5em]
%| (Int _, _, (IOp _)::_) -> 3
%\end{lstlisting}
\end{onlyenv}
\end{overlayarea}
\vspace{1cm}
\end{subfigure}
\end{figure}

\end{frame}

\begin{frame}{Conclusions and Future Work}
\begin{itemize}
\item An approach shows correct results on small problems...
\item ... but performs not fast enough
\begin{itemize}
\item Reification for structural constraints can be made faster (lazy computations)
\item Use finite-domain constraints instead of disequality constraints 
\item Memoization is not used (because of presence of disequality constraints)
\end{itemize}
\end{itemize}
\end{frame}

\begin{frame}
%\vspace{1cm}\pause
\begin{center}
{\Huge Thanks!}
\end{center}
\end{frame}

\begin{frame}[t, allowframebreaks]
\frametitle{References}
\bibliographystyle{amsalpha}
\bibliography{references}
\vspace{1cm}
\end{frame}

\end{document}
