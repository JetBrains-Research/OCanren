\section{Pattern Matching Synthesis, Relationally}
\label{sec:relationally}

In this section we describe a relational formulation for the pattern matching synthesis problem. Practically,
this amounts to constructing a goal with a free variable, corresponding to the switch program to synthesize,
for (arbitrary) list of patterns. In order to come up with a tractable goal certain steps have to be performed.
We first describe the general idea, and then consider these steps is details.

Our idea of using relational programming for pattern matching synthesis is based on the following observations:

\begin{itemize}
\item For the switch language we can implement a relational interpreter $eval^o_\ir$ with the following property: for
  arbitrary $v\in\mathcal V$, $\pi\in\ir$ and $i\in\mathbb N$
 
  \[
  \setarrow{\xrightarrow}
  \setsubarrow{_\ir}
   eval^o_\ir\, v\, \pi\, i \Longleftrightarrow \withenv{v}{\trans{\pi}{}{i}}
  \]

  In other words, $eval^o_\ir$ interprets a program $\pi$ for a scrutinee $v$ and returns exactly the same branch (if any)
  which is prescribed by the semantics of the switch language. 
  
\item On the other hand, we can directly encode the declarative semantics of pattern matching as a relational
  program $match^o$ such that for arbitrary $v\in\mathcal V$, $p_i\in\mathcal P$ and $i\in\mathbb N$

  \[
  \setarrow{\xrightarrow}
  match^o\,v\,p_1,\dots,p_k\,i \Longleftrightarrow \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i}
  \]

  Again, $match^o$ succeeds with $1\le i\le k$ iff $p_i$ is the leftmost pattern, matching $v$; otherwise it
  succeeds with $i=k+1$.
\end{itemize}

We address the construction of relational interpreters for both semantics in Section~\ref{sec:relints}.

Being relational, both $eval^o_\ir$ and $match^o$ do not just succeed or fail for ground arguments, but also can be \emph{queried} for
arguments with free logical variables, thus performing a search for all substitutions for these variables which make the
relation to hold. This observation leads us to the idea of utilizing the definition of pattern matching
synthesis problem, replacing ``$\xrightarrow{}{}$'' with $match^o$, ``$\xrightarrow{}{}_{\mathcal S}$`` with $eval^o$,
and $\pi$ with a free logical variable $\circled{?}$, which gives us the goal

\[
\forall v\in \mathcal V,\; \forall 1\le i\le n+1 : match^o\,v\,p_1,\dots,p_n\,i\Longleftrightarrow eval^o\,v\,\circled{?}\,i
\]

This goal, however, is problematic from relational point of view due to a number of reasons.

First, \textsc{miniKanren} provides rather a limited support for universal quantification. Apart from being inefficient from
the performance standpoint, existing implementations either do not coexist with disequality constaints~\cite{eigen}
or do not support quantified qoals with infinite number of answers~\cite{moiseenko}. As we will see below, both restrictions are
violated in our case. Second, there is no direct support for the equivalence of goals (``$\xLeftrightarrow{}{}$''). Thus,
reducing the original synthesis problem to a viable relational goal involves some ``massaging''.

We eliminate the universal quantification over the infinite set of scrutinees, replacing it by a \emph{finite}
conjunction over a \emph{complete set of samples}. For a sequence of patterns $p_1,\dots,p_k$ a
complete set of samples is a finite set of values $\mathcal{E}(p_1,\dots,p_k)\subseteq\mathcal{V}$ with the following
property:

\[
\setarrow{\xrightarrow}
\begin{array}{rcl}
  \forall\pi\in\mathcal S & : & [\forall v\in\mathcal{E}(p_1,\dots,p_k),\,\forall i\in\mathbb{N} : \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i} \Longleftrightarrow {\setsubarrow{_{\mathcal S}}\withenv{v}{\trans{\pi}{}{i}}}] \Longrightarrow \\
                          &   & [\forall v\in\mathcal V,\,\forall i\in\mathbb{N} : \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i} \Longleftrightarrow  {\setsubarrow{_{\mathcal S}}\withenv{v}{\trans{\pi}{}{i}}}]
\end{array}
\]

In other words, if a program implements a correct and complete pattern matching for all values in a complete set of samples, then this
program implements a correct and complete pattern matching for all values. The idea of using a complete set of samples originates from the following observation: each pattern
describes a (potentially infinite) set of values, and pattern matching splits the set of all values into equavalence classes, each corresponding to a certain matching pattern. Thus,
to form a complete set of samples it is enough to take a representative for each class. There are, however, some subtleties, which will be addressed below (see Section~\ref{sec:samples}).

\setarrow{\xrightarrow}

To eliminate the universal quantification over the set of answers we rely on the functionality of declarative pattern matching semantics. Indeed, given a fixed sequence $p_1,\dots,p_k$
of patterns, for every value $v$ there is exactly one answer value $i$, such that $\trans{\inbr{v;\,p_1,\dots,p_k}}{}{i}$. We can reformulate this property as

\[
\exists i\, \forall j : \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i} \Longrightarrow  j=i
\]

Thus, we can replace universal quantification over the sets of answers by existential one, for which we have an efficient relational counterpart~--- the ``\lstinline|fresh|''
construct.

Following the same argument, we may replace the equivalence with conjunction: indeed, if

\[
\setarrow{\xrightarrow}
\trans{\inbr{v;\,p_1,\dots,p_k}}{}{i}
\]

for some $i$, then (by functionality), for any other $j\ne i$

\[
\setarrow{\xrightarrow}
\neg\;(\trans{\inbr{v;\,p_1,\dots,p_k}}{}{j})
\]

A correct pattern matching implementation $\pi$ should satisfy the condition

\[
\setarrow{\xrightarrow}
\setsubarrow{_{\mathcal S}}
\withenv{v}{\trans{\pi}{}{i}}
\]

But, by the determinism of the switch language semantics, it immediately follows, that for arbitrary $j\ne i$

\[
\setarrow{\xrightarrow}
\setsubarrow{_{\mathcal S}}
\neg\;(\withenv{v}{\trans{\pi}{}{j}})
\]

Alternatively, we could switch to a more explicit relational representation of both semantics, adding extra boolean argument to
both $eval^o_{\mathcal S}$ and $match^o$ and using the same fresh variable $b$ in the query of interest:

\[
match^o\,v\,p_1,\dots,p_k\,i\,b \wedge eval^o_{\mathcal S}\,v\,\pi\,i\,b
\]

Thus, the goal we eventually came up with is

\[
\bigwedge_{v\in\mathcal{E}\,(p_1,\dots,p_k)}\mbox{\lstinline|fresh ($i$)|}\; \{match^o\,v\,p_1,\dots,p_k\,i \wedge eval^o_{\mathcal S}\,v\,\circled{?}\,i\}
\eqno{\star\star}
\]

\subsection{Dealing with a Complete Set of Samples}
\label{sec:samples}

A we observed before, a complete set of samples plays an important role in our approach: it allows us to eliminate universal quantification over the
set of all values. However, in order to make this idea work, we need to modify the semantics of the switch language a little bit. 

In order to construct a complete set of samples for a sequence of patterns $p_1,\dots,p_k$ we introduce a distinctive constructor ``$\bot$'' and
convert each pattern $p_i$ into a \emph{value} $\sembr{p_i}$, defined as follows:

\[
\begin{array}{rcl}
  \sembr{\_}               & = & \bot \\
  \sembr{C^k\,p_1\dots p_k} & = & C^k\,\sembr{p_1}\dots\sembr{p_k}
\end{array}
\]


\subsection{Constructing Relational Interpreters}
\label{sec:relints}
