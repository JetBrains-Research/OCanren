\section{Pattern Matching Synthesis, Relationally}

In this section we describe a relational formulation for the pattern matching synthesis problem. Practically,
this amounts to constructing a goal with a free variable, corresponding to the switch program to synthesize,
for (arbitrary) list of patterns. In order to come up with a tractable goal certain steps have to be performed.
We first describe the general idea, and then consider these steps is details.

Our idea of using relational programming for pattern matching synthesis is based on the following observations:

\begin{itemize}
\item For the switch language we can implement a relational interpreter $eval^o_\ir$ with the following property: for
  arbitrary $v\in\mathcal V$, $\pi\in\ir$ and $i\in\mathbb N$
 
  \[
  \setarrow{\xrightarrow}
  \setsubarrow{_\ir}
   eval^o_\ir\, v\, \pi\, i \Longleftrightarrow \withenv{v}{\trans{\pi}{}{i}}
  \]

  In other words, $eval^o_\ir$ interprets a program $\pi$ for a scrutinee $v$ and returns exactly the same branch (if any)
  which is prescribed by the semantics of the switch language. 
  
\item On the other hand, we can directly encode the declarative semantics of pattern matching as a relational
  program $match^o$ such that for arbitrary $v\in\mathcal V$, $p_i\in\mathcal P$ and $i\in\mathbb N$

  \[
  \setarrow{\xrightarrow}
  match^o\,v\,p_1,\dots,p_k\,i \Longleftrightarrow \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i}
  \]

  Again, $match^o$ succeeds with $1\le i\le k$ iff $p_i$ is the leftmost pattern, matching $v$; otherwise it
  succeeds with $i=k+1$.
\end{itemize}

Being relational, both $eval^o_\ir$ and $match^o$ do not just succeed or fail for ground arguments, but also can be \emph{queried} for
arguments with free logical variables, thus performing a search for all substitutions for these variables which make the
relation to hold. This observation leads us to the idea of utilizing the definition of pattern matching
synthesis problem, replacing ``$\xrightarrow{}{}$'' with $match^o$, ``$\xrightarrow{}{}_{\mathcal S}$`` with $eval^o$,
and $\pi$ with a free logical variable $\circled{?}$, which gives us the goal

\[
\forall v\in \mathcal V,\; \forall 1\le i\le n+1 : match^o\,v\,p_1,\dots,p_n\,i\Longleftrightarrow eval^o\,v\,\circled{?}\,i
\]

This goal, however, is problematic from relational point of view due to the number of reasons.

First, \textsc{miniKanren} provides rather a limited support for universal quantification. Apart from being inefficient from
the performance standpoint, existing implementations either do not coexist with disequality constaints~\cite{eigen}
or do not support quantified qoals with infinite number of answers~\cite{moiseenko}. As we will see below, both restrictions are
violated in our case. Second, there is no direct support for the equivalence of goals (``$\Leftrightarrow$''). Thus,
reducing the original synthesis problem to a viable relational goal involves some ``massaging''.

We eliminate the universal quantification over the infinite set of scrutinees, replacing it by a \emph{finite}
conjunction over a \emph{complete set of samples}. For a sequence of patterns $p_1,\dots,p_k$ a
complete set of samples is a finite set of values $\mathcal{E}(p_1,\dots,p_k)\subseteq\mathcal{V}$ with the following
property:

\[
\setarrow{\xrightarrow}
\begin{array}{rcl}
  \forall\pi\in\mathcal S & : & [\forall v\in\mathcal{E}(p_1,\dots,p_k),\,\forall i\in\mathbb{N} : \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i} \Longleftrightarrow {\setsubarrow{_{\mathcal S}}\withenv{v}{\trans{\pi}{}{i}}}] \Longrightarrow \\
                          &   & [\forall v\in\mathcal V,\,\forall i\in\mathbb{N} : \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i} \Longleftrightarrow  {\setsubarrow{_{\mathcal S}}\withenv{v}{\trans{\pi}{}{i}}}]
\end{array}
\]

In other words, a complete set of samples posesses the following property: if a program implements a correct and complete pattern matching for all values in this set, then this
program implements a correct and complete pattern matching for all values. The idea of using a complete set of samples originates from the following observation: each pattern
describes a (potentially infinite) set of values, and pattern matching splits the set of all values into equavalence classes, each corresponding to a matching pattern. Thus,
to form a complete set of samples it is enough to take a representative for each class. There are, however, some subtleties, which will be addressed below.

\setarrow{\xrightarrow}

To eliminate the universal quantification over the set of answers we rely on the functionality of declarative pattern matching semantics. Indeed, given a fixed sequence $p_1,\dots,p_k$
of patterns, for every value $v$ there is exactly one answer value $i$, such that $\trans{\inbr{v;\,p_1,\dots,p_k}}{}{i}$. We can reformulate this property as

\[
\exists i\, \forall j : \trans{\inbr{v;\,p_1,\dots,p_k}}{}{i} \Longrightarrow  j=i
\]

Thus, we can replace universal quantification over the sets of answers by existential one, for which we have an efficient relational counterpart~--- the ``\lstinline|fresh|''
construct.

Finally,

Thus, the goal we eventually came up with is

\[
\bigwedge_{v\in\mathcal{E}\,(p_1,\dots,p_k)}\mbox{\lstinline|fresh ($i$)|} match^o\,v\,p_1,\dots,p_k\,i \wedge eval^o_{\mathcal S}\,v\,\circled{?}\,i
\]

\begin{comment}
We implemented the synthesis framework using \textsc{OCanren}~--- an embedding of \textsc{miniKanren} into \textsc{OCaml}~\cite{ocanren},~---
 and evaluated it on the set of benchmarks, reported in the previous works on \emph{ad-hoc} algorithms for pattern matching
 code generation~\cite{maranget2001,maranget2008}. In comparison with a simplified setting, presented above, our implementation
 deals with a more elaborate pattern matching problem~--- in particular, we support \emph{guard expressions}, name bindings in
 patterns and incorporate a deterministic top-down matching strategy, which is common in functional languages.
 
 Initially, our synthesis did not demonstrate good results. However, we applied the following techniques to improve both the performance
 and the quality of synthesized programs:
 
 \begin{itemize}
 \item we restricted the shape of scrutinees using type information;
 \item we utilized tabling to memoize repeating search steps;
 \item we implemented a pruning technique, which makes the search stop exploring a certain branch if the program, synthesized so far,
   contains too much nesting constructs (this factor can be precomputed by patterns analysis).
 \end{itemize}
 
 With these adjustments, our synthesis framework in a negligible time provides the same results as those reported in the previous works.
 Our future steps include extending the pattern matching language to completely match that of \textsc{OCaml} (for
 now we do not support GADTs), integrate the synthesis into the existing \textsc{OCaml} compiler and evaluate it on a
 set of real-world programs. Another direction is extending the pattern matching language to incorporate features which
 are known to be hard, tedious or error-prone to implement (for example, non-linear patterns).
 
\end{comment}
