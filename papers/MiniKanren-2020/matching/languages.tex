Algebraic data types are essential for typed functional programming and it's difficult to imagine effective compiler without effective compilation of pattern matching. 
There are a few different approaches for compiling pattern mathcing. GHC is using influential paper~\cite{Jones1987}, OCaml is currently based on~\cite{maranget2001} although a work~\cite{maranget2008} can slightly improve effectiveness of generated code. 

Also there are a number of possible extensions of pattern matching itself (guards, non-linear patterns, active patterns) and extensions of possible matchable values (polymorphic variants in OCaml, for example). Although having all these extensions can be helpful for programming in practice, they can complicate compilation schema or make it very difficult to generate effective code. Supporting a large number  of extensions can seriously complicate compiler's implementation too.

We present an approach to pattern matching code generation based on application of relational programming~\cite{TRS,WillThesis} and, in
 particular, relational interpreters~\cite{unified}. We expect that our approach can compile pattern mathcing to competitive code and will be easier to support during adding of new pattern matching extensions.
 
\section{Semantics of pattern matching}
 In a simplified case, we consider a finite set of constructors with arities $\mathcal{C}$, a set of values $\mathcal{V}$,
 and a set of patterns $\mathcal{P}$
 
 \[
  \begin{array}{rcll}
     \mathcal{C} & = & \{ C_1^{k_1}, \dots, C_n^{k_n} \}\\
     \mathcal{V} & = & \mathcal{C}\,\mathcal{V}^*\\  
     \mathcal{P} & = & \_ \mid \mathcal{C}\,\mathcal{P}^*
  \end{array}
 \]
 
 and address a problem of matching a value (\emph{scrutinee}) against an ordered list of patterns.

\begin{figure}
   \[
   \begin{array}{cr}
     \dfrac{}{\inbr{v; \_}} & 
%      \ruleno{WildCard}
      \\[5mm]
     %\dfrac{\inbr{v,p_i}}{\sem{v;p_1,\dots, p_n}} & \ruleno{rule1}\\[5mm]
     \dfrac{v = C\ v_1\dots v_n\quad p = C\ p_1\dots p_n\quad  \inbr{v_1,p_1}\dots \inbr{v_n,p_n}}{\inbr{v;p}} & 
%     \ruleno{rule2}
   \end{array}
   \]
   \caption{Semantics $\inbr{v;p}$ of pattern matching scrutinee $v$ with single pattern $p$}
  \label{fig:match1pat}
\end{figure}
 
Matching scrutinee with single pattern is pretty straightforward and is described at Figure~\ref{fig:match1pat}.

In practice pattern matching if performed against finite sequence of \emph{clauses} which consist of pattern and some code which will consider as an natural number equal to pattern index, for simplicity. The clauses are ordered, i.e. pattern matching tries one pattern after another and stops on the first pattern that suites the scrutinee. If no patterns suit the scrutinee the pattern set is called \emph{non-exhaustive} and result of pattern matching is decide by predefined code.   

\begin{figure}
   \[
   \begin{array}{cr}
%     \inbr{v; \_} & \ruleno{WildCard}\\[2mm]
     %\dfrac{\inbr{v,p_i}}{\sem{v;p_1,\dots, p_n}} & \ruleno{rule1}\\[5mm]
     \dfrac{\exists i\ 1\le i\le n\ \quad \inbr{v, p_i}\quad \forall j\ 1\le j < i \quad \neg \inbr{v,p_j}}{\sembr{v; p_1\dots p_n; e_{fail}} \leadsto i} & 
%      \ruleno{rule2}
       \\[5mm]
     \dfrac{\neg (\exists i\ 1\le i\le n\ \quad \inbr{v, p_i})}{\sembr{v; p_1\dots p_n; e_{fail}} \leadsto e_{fail}} & 
%     \ruleno{rule2}
   \end{array}
   \]
   \caption{Semantics of pattern matching $\sembr{s; ps; e_{fail}}$ of scrutinee $v$ and sequence of patterns $ps$}
  \label{fig:match}
\end{figure}
 

We represent \emph{declarative semantics} of pattern matching (Figure~\ref{fig:match}) as a relation:
 
 \[
  \sembr{s; ps; e_{fail}} = i \Leftrightarrow   match\, (s, ps, i)
 \]
 
 where $s\in\mathcal{V}$ is a scrutinee, $ps\in\mathcal{P}^*$~--- an ordered list of patterns, and $i\in\mathbb{N}$~--- a natural number.
 This relation holds iff $s$ matches the $i$-th pattern of $ps$. For a fixed language of patterns $match$ can be implemented directly
 in \textsc{miniKanren} once and for all.
 
 On the other hand, we introduce a simple language $\ir$ (semantics on Figure~\ref{fig:ir}) of test-and-branch constructs:
 
 \[
 \begin{array}{rcl}
   \mathcal M & = & \bullet \\
              &   & \mathcal M\,[\mathbb{N}] \\
   \ir & = & \primi{return}\,\mathbb{N} \\
              &   & \primi{if}\;\mathcal{C}\;\mathcal{M}\;\primi{then}\;\ir\;\primi{else}\;\ir
 \end{array}
 \]
 
 Here $\mathcal{M}$ stands for a \emph{matchable expression}, which is either a reference to a scrutinee ("$\bullet$") or
 a denotation of some indexed subvalue of a matchable expression. The programs in $\ir$ can discriminate on the
 structure of matchable expressions, testing their top constructors and eventually returning natural numbers as results.
 The language $\ir$ is similar to the intermediate representations for pattern matching code, used in 
 previous works on pattern matching implementation~\cite{maranget2001,maranget2008}.
 
 
 \begin{figure}
    \[
    \begin{array}{cr}
      \dfrac{m \equiv \bullet} { m \rightrightarrows s} & 
 %      \ruleno{rule2}
        \\[5mm]
      \dfrac{m \equiv m'[i]\quad m'\rightrightarrows e\quad e\equiv C\;e_1\dots e_n\quad 1\le i\le n} { m \rightrightarrows e_i} & 
 %      \ruleno{rule2}
        \\[5mm]
      \dfrac{}{\primi{return}\ n \rightarrow n} &       
        \\[5mm]
      \dfrac{m \rightrightarrows e \quad e\equiv C\; e_1\dots e_n\quad th \rightarrow n} {\primi{if}\;\mathcal{C}\;m \; \primi{then}\;th\;\primi{else}\;el \rightarrow n} &       
 %     \ruleno{rule2}
        \\[5mm]
      \dfrac{m \rightrightarrows e \quad e\not\equiv C\; e_1\dots e_n\quad el \rightarrow n} {\primi{if}\;\mathcal{C}\;m\;\primi{then}\;th\;\primi{else}\;el \rightarrow n} &       
 %     \ruleno{rule2}
    \end{array}
    \]
    \caption{Semantics of scrutinee slicing $\mathcal{M} \rightrightarrows \mathcal{V}$ with top-level scrutinee $s$ and semantics $\ir\rightarrow \mathcal{N}$  of $\ir\;$ language
    }
   \label{fig:ir}
 \end{figure}
 
 We use a \emph{relational interpreter} for $\ir$
 
 \[
 eval^o_{\ir}\, (s, p, i)
 \]
 
 Here $s$ and $i$ have the same meaning as in declarative semantics description, $p\in\ir$~--- a syntactic representation of
 a program in $\ir$. The relation $eval^o_{\ir}$ encodes the operational semantics of $\ir$; it holds, if
 evaluating $p$ for $s$ returns $i$. Being relational interpreter, however, $eval^o_{\ir}$ is capable of solving a
 synthesis problem: by a scrutinee $s$ and a number $i$ calculate a program $p$ which makes the relation to hold.
 Within this setting, we can formulate the pattern-matching synthesis problem as follows: \emph{for a given ordered list of patterns $ps$ find a program $p$, such that}
 
 \[
 \forall s\in\mathcal{V},\,\forall i\in\mathbb{N},\,eval^o_{\ir}\, (s, p, i) \wedge\, match (s, ps, i)
 \]
 
 It is rather problematic to directly solve this synthesis problem with existing \textsc{miniKanren} implementations as
 they provide a rather limited support for universal quantification~\cite{eigen,moiseenko}. However, in our concrete
 case there is a simple way to alleviate this problem. Indeed, we may replace universal quantification over $i$ by
 a finite conjunction, as the length of $ps$ is known at the synthesis time. As for the quantification over $s$, for
 any concrete $ps$ we may precompute a \emph{complete set of examples} $\mathcal{E}(ps)\subseteq\mathcal{V}$ with the following
 property:
 
 \[
 \forall i\in\mathbb{N},\,(\forall s\in\mathcal{E}(ps),\,match\, (s, ps, i) \Leftrightarrow \forall s\in\mathcal{V},\,match\, (s, ps, i))
 \]
 
 It easy to see, that for arbitrary $ps$ there exists a finite complete set of examples (indeed, any pattern describes the ``shape''
 of a scrutinee up to some finite depth, beyond which all scrutinees become indistinguishable). Thus, for a given $ps$ we may
 completely eliminate the quantification, reformulating the synthesis problem as
 
 \[
 \bigwedge_{i\in[1\dots|ps|]}\,\bigwedge_{s\in\mathcal{E}(ps)} (eval^o_{\ir}\, (s, p, i) \wedge match\, (s, ps, i))
 \]
 
 We implemented the synthesis framework using \textsc{OCanren}~--- an embedding of \textsc{miniKanren} into \textsc{OCaml}~\cite{ocanren},~---
 and evaluated it on the set of benchmarks, reported in the previous works on \emph{ad-hoc} algorithms for pattern matching
 code generation~\cite{maranget2001,maranget2008}. In comparison with a simplified setting, presented above, our implementation
 deals with a more elaborate pattern matching problem~--- in particular, we support \emph{guard expressions}, name bindings in
 patterns and incorporate a deterministic top-down matching strategy, which is common in functional languages.
 
 Initially, our synthesis did not demonstrate good results. However, we applied the following techniques to improve both the performance
 and the quality of synthesized programs:
 
 \begin{itemize}
 \item we restricted the shape of scrutinees using type information;
 \item we utilized tabling to memoize repeating search steps;
 \item we implemented a pruning technique, which makes the search stop exploring a certain branch if the program, synthesized so far,
   contains too much nesting constructs (this factor can be precomputed by patterns analysis).
 \end{itemize}
 
 With these adjustments, our synthesis framework in a negligible time provides the same results as those reported in the previous works.
 Our future steps include extending the pattern matching language to completely match that of \textsc{OCaml} (for
 now we do not support GADTs), integrate the synthesis into the existing \textsc{OCaml} compiler and evaluate it on a
 set of real-world programs. Another direction is extending the pattern matching language to incorporate features which
 are known to be hard, tedious or error-prone to implement (for example, non-linear patterns).
 
 \begin{comment}
 
 
 Real world modern compilers are obliged to address a few problems which are NP-complete and hence can't have effective
 algorithm to solve them. So, compilers use semi-optimal algorithms to find a decent solution. Optimal algorithms require
 brute force search to get the best solution and  affect compilation speed negatively. In this work we apply relational
 programming -- a convenient DSL for implementing search -- to compilation of pattern matching, one of a kind hard problems for compiler.
 
 The task of compiling pattern matching for typed languages is well presented in literature~\cite{maranget2001,maranget2008}.
 
 
 We test approach on simplified source language $PM$ where scrutinee is a value $\in\mathcal{V}$ of algebraic data type, only wildcards
 and nested constructors are allowed as patterns $\mathcal{P}$ and right hand side of clause is its index. The source language is easy
 extendable by pattern variables and optional pattern guards that test subterms of scrutinee using a function. The semantics of $PM$
 is a function from concrete scrutinee $s$, concrete patterns $pats$ and concrete guards $gs$ to clause indexes, and is denoted
 as $\sem{s,pats,gs}_{PM} = i$.
 
 Compilation scheme translates sentences from $PM$ to $\ir$ language which has constructions for clause indexes and conditions which
 test matchable values for specific constructor. Matchable values can be either a scrutinee, or a projection of matchable value that
 returns one of its field indexed by natural numbers. $\ir$ language is easy extendable by tests for fixed number of pattern guards.
 The semantics is straightforward and is denoted by $\sem{\cdot}_{\ir}$.
 
 We deal with a task of compiling pattern matching as it is a synthesis problem. The goal of algorithm is to synthesize $ideal_\ir$
 for concrete patterns $pats$ and guards that, firstly, will behave the same as original pattern matching for any possible
 scrutinee $s$. Secondly, we want shortest solution because short code usually runs faster. Relational programming~\cite{OCanren}
 will help with that because it has a tendency to generate short answers earlier, although this tendency is not strict.
 
 $$
 \forall s:\; \sem{s; ideal_\ir}_\ir = \sem{s;pats}_{PM}
 $$
 
 To eliminate universal quantifier we use the following observation: for \emph{finite} amount of patterns of \emph{finite} height
 we can generate \emph{finite} amount of examples to test pattern matching semantics. In examples, very deep subterms can have
 any value because they will not be tested during pattern matching. We can reformulate synthesis problem as follows:
 
 $$
 \mid  Examples\mid < \infty\quad \land\quad \left(\forall e \; (e\in Examples)\quad\land \quad\left( \sem{e; ideal_\ir}_\ir = \sem{e;pats}_{PM}\right)\right)
 $$
 
 For plain ADT the approach will generate required examples in finite time, but for GADTs it can diverge because inhabitancy problem
 is semi-decidable~\cite{garrigue2017gadts}(chapter 5). Inhabitants generation as well as synthesis algorithm is
 implemented\footnote{\url{https://github.com/Kakadu/pat-match/}} using relational programming.
 
 Presented approach is good as general description of an idea but require a few tweaks to start working, for example, on presented
 sample~\ref{fig:example1} . Firstly, synthesis procedure in a way as it is described doesn't take types into account, so it is
 useful to give hints about which parts of scrutinee should be checked for which constructors. Second observation says that we
 run $\sem{\cdot}_\ir$ in concrete direction, so it is possible to check periodically count of \texttt{IfTag} constructors in
 result value and prune branches where it becomes too big. Thirdly, synthesis query generates a lot of similar queries, and
 we use tabling to speedup search. All three observations are important, removing one of them leads to visible performance degradation.
 
 The optimal (two \texttt{IfTag}'s) and the semi-optimal solution (three \texttt{IfTag}'s) for~\ref{fig:example1} are described
 in~\cite{maranget2008}. Current implementation generates semi-optimal solution as 28th answer. Before that it generates optimal
 solution (and it's equivalents) three times, other 24 answers are longer and less useful. All tasks (example generation, synthesis
 and printing answers) take 3 seconds, which is unfortunate.
 
 Shortly, we present following contributions
 \begin{itemize}
 \item Code synthesis for pattern matching works after implementing \emph{three optimizations} above.
 \item GADTs, pattern binding and guards works for simple examples, the approach is easy extendable by them.
 \end{itemize}
 
 Future work is
 \begin{itemize}
 \item Discover other optimizations and enable current ones automatically using type information (at the moment we patched synthesis
   algorithm manually for concrete example).
 \item When current implementation tests for \texttt{cons} tag it can't propagate constraint that tag equals to \texttt{nil} to
   the \texttt{else} branch, which partially explains why branch pruning is so useful.
 \item Algorithm for inhabitant generation requires proper formulation and proof.
 \item Apply current synthesis procedure for exhaustiveness checking which will give us \emph{single} procedure for compilation and exhaustiveness checking.
 \item Test the approach on real world problems (embedding to OCaml compiler).
 \end{itemize}
 
 
 \begin{figure}[t]
   \[
   \begin{array}{rcll}
     \mathcal{C} & = & \{ C_1^{k_1}, \dots, C_n^{k_n} \}    &\mbox{(constructors)} \\
     \mathcal{V} & = & \mathcal{C}\,\mathcal{V}^*        &\mbox{(values)}       \\
     \mathcal{P} & = & \_ \mid \mathcal{C}\,\mathcal{P}^*&\mbox{(patterns)}     \\
     \mathcal{M} & = & \bullet \mid \mathcal{M} [\mathbb{N}]&
 
   \end{array}
   \]
 \end{figure}
 
 \begin{figure}
 \centering
 \begin{minipage}{.7\textwidth}
   \centering
 \begin{align*}
 \mathcal{C} =&\; \{ C_1^{k_1}, \dots, C_n^{k_n} \} \\
 \mathcal{V} =&\;  \mathcal{C}\ \mathcal{V}^*\\
 \mathcal{M} =&\;  \mathcal{S} \\
           \mid\; &\; \text{\texttt{Field}}\;  \mathcal{M}\times  \mathbb{N}\\
 \mathcal{P} =&\;  \text{\texttt{Wildcard}} \\
           \mid\; &\; \text{\texttt{Var}}\  Name\\
           \mid\; &\; \text{\texttt{PConstructor}}\  \mathcal{C}\times  \mathcal{P}^*\\
 \ir  =&\; \text{\texttt{Int}}\  \mathbb{N} \\
 %           \mid\; &\;\mathcal{S} \\
            \mid\; &\; \text{\texttt{IfTag}}\; \mathcal{C}\times \mathcal{M}\times \ir\times \ir\\
            \mid\; &\; \text{\texttt{IfGuard}}\ \mathbb{N}\times (Name\times \mathcal{M})^*\times \ir\times \ir\\
 Clause =&\;  \mathcal{P} \times \mathbb{N}? \times \ir
 \end{align*}
   \captionof{figure}{Structure of $PM$ and \ir languages}
 %  \label{fig:test1}
 \end{minipage}%
 \begin{minipage}{.3\textwidth}
   \centering
 \begin{lstlisting}[language=ocaml]
 match s with 
 | ([], _)     -> 1
 | (_, [])     -> 2
 | (_::_,_::_) -> 3
 \end{lstlisting}
   \captionof{figure}{Simple example of pattern matching problem from~\cite{maranget2008}}
 \label{fig:example1}
 \end{minipage}
 \end{figure}
 
 \end{comment}
 