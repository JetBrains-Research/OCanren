\section{Application}

In this section we consider some applications of the framework and results, described in the previous sections.

\subsection{Correctness of Transformations}

One important immediate corollary of theorems we've proven is the justification of correctness for certain program transformations.
The completeness of interleaving search guarantees the correctness of any transformation which preserves the denotational semantics,
for example:

\begin{itemize}
\item changing the order of constituents in conjunctions and disjunctions;
\item distributing conjunctions over disjunctions and vice versa, for example, normalising goals info CNF or DNF;
\item moving fresh variable introduction upwards/downwards, for example, transforming any relation into a top-level fresh
  construct with a freshless body.
\end{itemize}

Note that this way we can guarantee only the preservation of results as \emph{sets of ground terms}; the other aspects of program behavior,
such as termination, may be affected by some of these transformations. 

As an example of these transformations application we consider the transformation from \textsc{Prolog} to conventional \textsc{miniKanren} and,
more interesting, in the opposite direction.

Since in \textsc{Prolog} a rather limited form of goals (an implicit conjunction of atoms) is used the conversion to \textsc{miniKanren} is easy:

\begin{itemize}
  \item built-in constructors in \textsc{Prolog} terms (for examples, for lists) are converted into \textsc{miniKanren} representation;
  \item each atom is converted into a corresponding relational invocation with the same parameters (modulo the conversion of terms);
  \item the list of atoms in the body of \textsc{Prolog} clause is converted into explicit conjunction;
  \item a number of fresh variables (one for each argument) is created and these variables are unified with terms in corresponding
    argument position in the head of corresponding clause;
  \item different clauses for the same predicate are combined using disjunction.
\end{itemize}

For example, consider the result of conversion from \textsc{Prolog} definition for list appending relation into \textsc{miniKanren}.
Like in \textsc{miniKanren}, the definition consists of two clauses. The first one is

\begin{lstlisting}
  append ([], X, X).
\end{lstlisting}

and the result of conversion is

\begin{lstlisting}
  append$^o$ = fun x y z .
    fresh X . x == Nil /\
              y == X   /\
              z == X
\end{lstlisting}

The second one is

\begin{lstlisting}
  append ([H$|$T], Y, [H$|$TY]) :- append (T, Y, TY).
\end{lstlisting}

which is convered into

\begin{lstlisting}
  append$^o$ = fun x y z .
    fresh H T Y TY . x == Cons (H, T)  /\
                     y == Y            /\
                     z == Cons (H, TY) /\
                     append$^o$ (T, Y, TY)
\end{lstlisting}

The overall result is not literally the same as what we've shown in Section~\ref{language}, but denotationally equivalent.

The conversion in the opposite direction involves the following steps:

\begin{itemize}
  \item converting between term representation;
  \item moving all ``\lstinline|fresh|'' constructs into the top-level;
  \item transforming the freshless body into DNF;
  \item replacing all unifications with calls for a specific predicate ``\lstinline|unify/2|'', defined as

    \begin{lstlisting}
      unify (X, X).
    \end{lstlisting}    

  \item splitting top-level disjunctions into separate clauses with the same head.
\end{itemize}

The correctness of these, again, can be justified denotationally. For the appendo relation in Section~\ref{language} the result
can be as follows:

\begin{lstlisting}
  append (X, Y, Z) :- unify (X, []), unify (Z, Y).
  append (X, Y, Z) :-
    unify (X, [H$|$T]),
    unify (Z, [H$|$TY]),
    append (T, Y, TY).
\end{lstlisting}

This transformations show that we can, for example, interpret \textsc{Prolog} specifications in interleaving semantics; moreover, we can,
using the certified framework we developed, describe conventional \textsc{Prolog} search strategies.

\subsection{SLD Semantics}

The conventional for \textsc{Prolog} SLD search differs from the interleaving one in just one aspect~--- it does not perform interleaving.
Thus, changing just two rules in the operational semantics converts interleaving search into the depth-first one:

\[
  \begin{array}{cr}
    \dfrac{s_1 \xrightarrow{\circ} s'_1}{(s_1 \oplus s_2) \xrightarrow{\circ} (s'_1 \oplus s_2)} &\ruleno{DisjStep}\\[5mm]
    \dfrac{s_1 \xrightarrow{r} s'_1}{(s_1 \oplus s_2) \xrightarrow{r} (s'_1 \oplus s_2)} &\ruleno{DisjStepAns}\\[5mm]
  \end{array}
\]

With this definition we can almost completely reuse the mechanized proof of soundness (with just cosmetic changes); the completeness, however,
can no longer be proven (as it does not hold anymore).

\subsection{Cut}

Now, cuts.

New states:

\[
S = \mathcal{G}\times\Sigma\times\mathbb{N}\mid S\oplus S \mid  S \circledast S \mid S \otimes \mathcal{G}
\]


Changing \textsc{ConjStepAns} to

  \[
  \begin{array}{cr}
    \dfrac{s \xrightarrow{(\sigma, n)} s'}{(s \otimes g) \xrightarrow{\circ} (\inbr{g, \sigma, n} \circledast (s' \otimes g))} & \ruleno{ConjStepAns} 
  \end{array}
  \]
  
Adding simple rules for asterisk (the same as those for plus):

  \[
  \begin{array}{cr}
    \dfrac{s_1 \xrightarrow{\circ} \Diamond}{(s_1 \circledast s_2) \xrightarrow{\circ} s_2} & \ruleno{AstStop}\\[5mm]
    \dfrac{s_1 \xrightarrow{r} \Diamond}{(s_1 \circledast s_2) \xrightarrow{r} s_2} & \ruleno{AstStopAns}\\[5mm]
    \dfrac{s_1 \xrightarrow{\circ} s'_1}{(s_1 \circledast s_2) \xrightarrow{\circ} (s'_1 \circledast s_2)} &\ruleno{AstStep}\\[5mm]
    \dfrac{s_1 \xrightarrow{r} s'_1}{(s_1 \circledast s_2) \xrightarrow{r} (s'_1 \circledast s_2)} &\ruleno{AstStepAns}\\[5mm]
  \end{array}
\]
  
Cut signal creation:

  \[
  \begin{array}{cr}
    \inbr{!, \sigma, n} \xrightarrow{(\sigma, n)}_c \Diamond &\ruleno{UnifyFail} \\[2mm]
  \end{array}
\]

Cut signal for pluses and asterisks:

  \[
  \begin{array}{cr}
    \dfrac{s_1 \xrightarrow{\circ}_c \Diamond}{(s_1 \oplus s_2) \xrightarrow{\circ} \Diamond} & \ruleno{PlusStopC}\\[5mm]
    \dfrac{s_1 \xrightarrow{r}_c \Diamond}{(s_1 \oplus s_2) \xrightarrow{r} \Diamond} & \ruleno{PlusStopAnsC}\\[5mm]
    \dfrac{s_1 \xrightarrow{\circ}_c s'_1}{(s_1 \oplus s_2) \xrightarrow{\circ} s'_1} &\ruleno{PlusStepC}\\[5mm]
    \dfrac{s_1 \xrightarrow{r}_c s'_1}{(s_1 \oplus s_2) \xrightarrow{r} s'_1} &\ruleno{PlusStepAnsC}\\[5mm]
    \dfrac{s_1 \xrightarrow{\circ}_c \Diamond}{(s_1 \circledast s_2) \xrightarrow{\circ}_c \Diamond} & \ruleno{AstStopC}\\[5mm]
    \dfrac{s_1 \xrightarrow{r}_c \Diamond}{(s_1 \circledast s_2) \xrightarrow{r}_c \Diamond} & \ruleno{AstStopAnsC}\\[5mm]
    \dfrac{s_1 \xrightarrow{\circ}_c s'_1}{(s_1 \circledast s_2) \xrightarrow{\circ}_c s'_1} &\ruleno{AstStepC}\\[5mm]
    \dfrac{s_1 \xrightarrow{r}_c s'_1}{(s_1 \circledast s_2) \xrightarrow{r}_c s'_1} &\ruleno{AstStepAnsC}\\[5mm]
  \end{array}
  \]
  
And cut signal propogation in crosses (just adding $c$ to all arrows)

\subsection{Reference Interpreters}
