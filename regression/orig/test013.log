fun q -> LBool.noto LBool.truo q, 1 answer {
q=false;
}
fun q -> LBool.noto LBool.falso q, 1 answer {
q=true;
}
fun q -> LBool.noto q LBool.truo, 1 answer {
q=false;
}
fun q -> LBool.oro LBool.falso LBool.falso q, 1 answer {
q=false;
}
fun q -> LBool.oro LBool.falso LBool.truo q, 1 answer {
q=true;
}
fun q -> LBool.oro LBool.truo LBool.falso q, 1 answer {
q=true;
}
fun q -> LBool.oro LBool.truo LBool.truo q, 1 answer {
q=true;
}
fun q -> LBool.ando LBool.falso LBool.falso q, 1 answer {
q=false;
}
fun q -> LBool.ando LBool.falso LBool.truo q, 1 answer {
q=false;
}
fun q -> LBool.ando LBool.truo LBool.falso q, 1 answer {
q=false;
}
fun q -> LBool.ando LBool.truo LBool.truo q, 1 answer {
q=true;
}
fun q -> LNat.addo ((?$) 0) ((?$) 1) q, 1 answer {
q=S (O ());
}
fun q -> LNat.addo ((?$) 1) q ((?$) 3), 1 answer {
q=S (S (O ()));
}
fun q r -> LNat.addo q r q, 3 answers {
q=O (); r=O ();
q=S (O ()); r=O ();
q=S (S (O ())); r=O ();
}
fun q -> LNat.mulo ((?$) 1) ((?$) 2) q, 1 answer {
q=S (S (O ()));
}
fun q -> LNat.mulo ((?$) 3) q ((?$) 6), 1 answer {
q=S (S (O ()));
}
fun q -> LNat.mulo ((?$) 3) q ((?$) 6), 1 answer {
q=S (S (O ()));
}
fun q -> LNat.mulo ((?$) 3) ((?$) 0) q, 1 answer {
q=O ();
}
fun q -> LNat.mulo q ((?$) 5) ((?$) 0), 1 answer {
q=O ();
}
fun q -> LNat.mulo q ((?$) 0) ((?$) 0), 3 answers {
q=O ();
q=S (O ());
q=S (S (O ()));
}
fun q -> sumo (nats []) q, 1 answer {
q=O ();
}
fun q -> sumo (nats [3; 1; 2]) q, 1 answer {
q=S (S (S (S (S (S (O ()))))));
}
fun q -> sumo ((%) ((?$) 0) ((%) ((?$) 1) ((%<) q ((?$) 3)))) ((?$) 6), 1 answer {
q=S (S (O ()));
}
fun q -> LList.lengtho (nats [1; 2; 3; 4]) q, 1 answer {
q=S (S (S (S (O ()))));
}
fun q -> LList.lengtho (list (!!) [(); (); ()]) q, 1 answer {
q=S (S (S (O ())));
}
fun q -> LList.lengtho (bools [false; true]) q, 1 answer {
q=S (S (O ()));
}
fun q -> LList.lengtho (nats [4; 3; 2; 1; 0]) q, 1 answer {
q=S (S (S (S (S (O ())))));
}
fun q -> LList.lengtho q ((?$) 0), 1 answer {
q=[];
}
fun q -> LList.anyo (bools [false; false; true]) q, 1 answer {
q=true;
}
fun q -> LList.anyo (bools [false; false]) q, 1 answer {
q=false;
}
fun q -> LList.allo (bools [true; false; true]) q, 1 answer {
q=false;
}
fun q -> LList.allo ((%) LBool.truo ((%<) q LBool.truo)) LBool.truo, 1 answer {
q=true;
}
fun q r s -> LList.allo ((%) LBool.truo ((%<) q r)) s, all answers {
q=true; r=true; s=true;
q=false; r=false; s=false;
q=false; r=true; s=false;
q=true; r=false; s=false;
}
fun q -> LList.mapo (LNat.addo ((?$) 1)) (nats [0; 1; 2]) q, 1 answer {
q=[S (O ()); S (S (O ())); S (S (S (O ())))];
}
fun q -> LList.mapo (LNat.addo ((?$) 2)) q (nats [4; 3; 2]), 1 answer {
q=[S (S (O ())); S (O ()); O ()];
}
fun q -> LList.mapo (LNat.addo q) (nats [1; 2; 3]) (nats [4; 5; 6]), 1 answer {
q=S (S (S (O ())));
}
fun q -> LList.mapo (LNat.mulo q) (nats [1; 2; 3]) (nats [2; 4; 6]), 1 answer {
q=S (S (O ()));
}
fun q r -> LList.mapo (LNat.mulo q) (nats [1; 2]) ((%<) ((?$) 2) r), 1 answer {
q=S (S (O ())); r=S (S (S (S (O ()))));
}
fun q -> LList.mapo (===) (nats [1; 2; 3]) q, 1 answer {
q=[S (O ()); S (S (O ())); S (S (S (O ())))];
}
fun q -> LList.mapo (===) (nats [1; 2; 3]) ((%) ((?$) 1) ((%<) ((?$) 2) q)), 1 answer {
q=S (S (S (O ())));
}
fun q -> LList.mapo LBool.noto (bools [true; false; true]) q, 1 answer {
q=[false; true; false];
}
fun q -> LList.mapo LBool.noto (bools []) q, 1 answer {
q=[];
}
fun q -> LList.filtero (eqo ((?$) 2)) (nats [0; 1; 2; 3]) q, all answers {
q=[S (S (O ()))];
}
fun q -> LList.lookupo (eqo ((?$) 1)) (nats [0; 2; 1; 3]) q, 1 answer {
q=Some (S (O ()));
}
fun q r -> LNat.mulo q r q, 3 answers {
q=O (); r=_.11;
q=S (O ()); r=S (O ());
q=S (S (O ())); r=S (O ());
}
fun q -> LList.lengtho q ((?$) 3), all answers {
q=[_.11; _.14; _.17];
}
