(*
 * MiniKanren: miniKanren primitives implementation.
 * Copyright (C) 2015
 * Dmitri Boulytchev, Dmitry Kosarev, St.Petersburg State University
 * 
 * This software is free software; you can redistribute it and/or
 * modify it under the terms of the GNU Library General Public
 * License version 2, as published by the Free Software Foundation.
 * 
 * This software is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 * 
 * See the GNU Library General Public License version 2 for more details
 * (enclosed in the file COPYING).
 *)

(** {1 Implementation of miniKanren primitives} *)

(** {2 Basic modules and types} *)

(** State (needed to perform calculations) *)
module State :
  sig
    (** State type *)
    type t

    (** Printing helper *)
    val show : t -> string
  end

(** Goal converts a state into a lazy stream of states *)
type goal = State.t -> State.t MKStream.t

(** Minikanren integers *)
type int = GT.int

(** Minikanren strings *)
type string = GT.string

(** Minikanren lists *)
type 'a list = 'a GT.list

(*
(** {2 Printing functions} *)

(** [show_var st x k] inspects [x] w.r.t. state [st] and either shows it
    as a variable (bound in [st]) or returns the value generated by
    continuation [k] *)
val show_var : State.t -> 'a -> (unit -> string) -> string

(** Printing helper for minikanren lists (requires state to discover 
    bindings of logical variables) *)
val show_list : State.t -> (State.t -> 'a -> string) -> 'a list -> string

(** Printing helper for minikanren ints (requires state to discover 
    bindings of logical variables) *)
val show_int : State.t -> int -> string

(** Printing helper for minikanren strings (requires state to discover 
    bindings of logical variables) *)
val show_string : State.t -> string -> string
*)

class mkshow_string_t :
  object method t_string : State.t -> string -> string end
class mkshow_int_t : object method t_int : State.t -> int -> string end
class ['a] mkshow_list_t :
  object
    method c_Cons :
      State.t ->
      (State.t, 'a GT.list, string, < a : State.t -> 'a -> string >) GT.a ->
      (State.t, 'a, string, < a : State.t -> 'a -> string >) GT.a ->
      (State.t, 'a GT.list, string, < a : State.t -> 'a -> string >) GT.a ->
      string
    method c_Nil :
      State.t ->
      (State.t, 'a GT.list, string, < a : State.t -> 'a -> string >) GT.a ->
      string
    method t_list :
      (State.t -> 'a -> string) -> State.t -> 'a GT.list -> string
  end
val mkshow : ('a, < mkshow : 'b; .. >) GT.t -> 'b
val int :
  (('a, 'b) #GT.int_tt -> 'a -> GT.int -> 'b,
   < compare : GT.int -> GT.int -> GT.comparison;
     eq : GT.int -> GT.int -> GT.bool; foldl : 'c -> GT.int -> 'c;
     foldr : 'd -> GT.int -> 'd; html : GT.int -> HTMLView.er;
     map : GT.int -> GT.int; mkshow : State.t -> GT.int -> string;
     show : GT.int -> string >)
  GT.t
val string :
  (('a, 'b) #GT.string_tt -> 'a -> GT.string -> 'b,
   < compare : GT.string -> GT.string -> GT.comparison;
     eq : GT.string -> GT.string -> GT.bool; foldl : 'c -> GT.string -> 'c;
     foldr : 'd -> GT.string -> 'd; html : GT.string -> HTMLView.er;
     map : GT.string -> GT.string; mkshow : State.t -> GT.string -> string;
     show : GT.string -> GT.string >)
  GT.t
val list :
  (('a -> 'b -> 'c) ->
   ('b, 'a, 'c, 'd, 'e) #GT.list_tt -> 'd -> 'b GT.list -> 'e,
   < compare : ('f -> 'f -> GT.comparison) ->
               'f GT.list -> 'f GT.list -> GT.comparison;
     eq : ('g -> 'g -> GT.bool) -> 'g GT.list -> 'g GT.list -> GT.bool;
     foldl : ('h -> 'i -> 'h) -> 'h -> 'i GT.list -> 'h;
     foldr : ('j -> 'k -> 'j) -> 'j -> 'k GT.list -> 'j;
     html : ('l -> HTMLView.er) -> 'l GT.list -> HTMLView.er;
     map : ('m -> 'n) -> 'm GT.list -> 'n GT.list;
     mkshow : (State.t -> 'o -> string) -> State.t -> 'o GT.list -> string;
     show : ('p -> GT.string) -> 'p GT.list -> GT.string >)
  GT.t

(** {2 miniKanren basic primitives} *)

(** [call_fresh f] creates a fresh logical variable and passes it to the
    parameter *)
val call_fresh : ('a -> State.t -> 'b) -> State.t -> 'b

(** [x === y] creates a goal, which performs a unifications of
    [x] and [y] *)
val (===) : 'a -> 'a -> goal

(** [conj s1 s2] creates a goal, which is a conjunction of its arguments *)
val conj : goal -> goal -> goal

(** [&&&] is left-associative infix synonym for [conj] *)
val (&&&) : goal -> goal -> goal

(** [disj s1 s2] creates a goal, which is a disjunction of its arguments *)
val disj : goal -> goal -> goal

(** [|||] is left-associative infix synonym for [disj] *)
val (|||) : goal -> goal -> goal

(** [?| [s1; s2; ...; sk]] calculates [s1 ||| s2 ||| ... ||| sk] for a
    non-empty list of goals *)
val (?|) : goal list -> goal

(** [conde] is a synonym for [?|] *)
val conde : goal list -> goal

(** [?& [s1; s2; ...; sk]] calculates [s1 &&& s2 && ... &&& sk] for a
    non-empty list of goals *)
val (?&) : goal list -> goal

(** {2 Top-level running primitives} *)

(** [run s] runs a state transformer [s] (not necessarily a goal) in
    initial state *)
val run : (State.t -> 'a) -> 'a

(** [refine s x] refines a logical variable [x] (created with [fresh]) w.r.t.
    state [s] *)
val refine : State.t -> 'a -> 'a

(** [take ?(n=k) s] takes at most [k] first answers from the lazy
    stream [s] (reexported from MKStream for convenience) *)
val take : ?n:int -> State.t MKStream.t -> State.t list
